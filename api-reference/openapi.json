{
  "openapi": "3.1.0",
  "info": {
    "title": "Recoup API",
    "description": "API documentation for the Recoup platform - an AI agent platform for the music industry",
    "license": {
      "name": "MIT"
    },
    "version": "1.0.0"
  },
  "servers": [
    {
      "url": "https://recoup-api.vercel.app"
    }
  ],
  "security": [
    {
      "apiKeyAuth": []
    }
  ],
  "paths": {
    "/api/tasks": {
      "get": {
        "description": "Retrieve scheduled tasks from the database. Tasks have cron-based execution schedules. Supports filtering by id, account_id, or artist_account_id.",
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "description": "Filter by task ID (UUID). Returns a single task matching the provided ID.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "account_id",
            "in": "query",
            "description": "Filter tasks to only include those for the specified account.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "artist_account_id",
            "in": "query",
            "description": "Filter tasks to only include those for the specified artist account.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Tasks retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TasksResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "post": {
        "description": "Create a new scheduled task. All fields are required. The response shape matches the GET endpoint (an array containing the created task).",
        "requestBody": {
          "description": "Task to create",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTaskRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Task created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TasksResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "patch": {
        "description": "Update an existing scheduled task. Only the id field is required; any additional fields you include will be updated on the task. The response shape matches the GET endpoint (an array containing the updated task).",
        "requestBody": {
          "description": "Task fields to update",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateTaskRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Task updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TasksResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Delete an existing scheduled task by its ID. Returns the status of the delete operation.",
        "requestBody": {
          "description": "Task to delete",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteTaskRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Task deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteTaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/api/tasks/runs": {
      "get": {
        "description": "Check the status of a triggered task run. Returns the current status and, if complete, the task response data.",
        "parameters": [
          {
            "name": "runId",
            "in": "query",
            "description": "The unique identifier of the task run to check",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Task run status retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskRunResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing or invalid runId",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Task run not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/api/accounts/{id}": {
      "get": {
        "description": "Retrieve detailed account information by ID. Returns the account with associated profile info, emails, and wallet addresses.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier (UUID) of the account",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Account retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetAccountResponse"
                }
              }
            }
          },
          "404": {
            "description": "Account not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/accounts/id": {
      "get": {
        "description": "Retrieve the ID of the authenticated account associated with the provided credentials. This is useful when you have an API key or access token but do not yet know the corresponding accountId.",
        "parameters": [],
        "security": [
          {
            "apiKeyAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "Account ID retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetAccountIdResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - missing or invalid credentials",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/accounts": {
      "post": {
        "description": "Create a new account or retrieve an existing account by email or wallet address. If an account with the provided email or wallet already exists, returns that account. Otherwise creates a new account and initializes credits.",
        "requestBody": {
          "description": "Account credentials to create or lookup",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateAccountRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Account created or retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountDataResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - failed to create account",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountErrorResponse"
                }
              }
            }
          }
        }
      },
      "patch": {
        "description": "Update an existing account's profile information including name, organization, image, instruction, job title, role type, company name, and knowledges.",
        "requestBody": {
          "description": "Account fields to update",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateAccountRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Account updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountDataResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - account not found or update failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/accounts/artists": {
      "post": {
        "description": "Add an artist to an account's list of associated artists. If the artist is already associated with the account, returns success without modification.",
        "requestBody": {
          "description": "Account and artist identifiers",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddArtistToAccountRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Artist added to account successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddArtistSuccessResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - account not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/artists": {
      "get": {
        "description": "Retrieve artists accessible to the authenticated account. The account is derived from the API key or Bearer token. When org_id is omitted, returns only personal (non-organization) artists. Pass org_id to view artists in a specific organization. Organization API keys can optionally filter by account_id to view a specific member's artists.",
        "parameters": [
          {
            "name": "account_id",
            "in": "query",
            "description": "Filter to a specific account's artists. Only usable by organization API keys to view a member's artists. Personal API keys and Bearer tokens derive the account automatically.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "org_id",
            "in": "query",
            "description": "Filter to artists in a specific organization. When omitted, returns only personal (non-organization) artists.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Artists retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtistsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - invalid parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtistsErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - missing or invalid authentication"
          },
          "403": {
            "description": "Forbidden - account_id is not accessible with the provided credentials"
          }
        }
      },
      "post": {
        "description": "Create a new artist account. The artist can optionally be linked to an organization.",
        "requestBody": {
          "description": "Artist creation parameters",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateArtistRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Artist created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateArtistResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - validation error or invalid JSON",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateArtistError"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/api/artist/segments": {
      "get": {
        "description": "Retrieve all segments associated with an artist. This endpoint should be called before using the Segment Fans endpoint to obtain the necessary segment IDs. Supports pagination.",
        "parameters": [
          {
            "name": "artist_account_id",
            "in": "query",
            "description": "The unique identifier of the artist account to fetch segments for",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "The page number to retrieve (default: 1)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 1
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of records per page (default: 20, max: 100)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "maximum": 100
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Segments retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtistSegmentsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtistSegmentsErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/artist/socials": {
      "get": {
        "description": "Retrieve all social media profiles associated with an artist. This endpoint should be called before using the Social Posts endpoint to obtain the necessary social IDs.",
        "parameters": [
          {
            "name": "artist_account_id",
            "in": "query",
            "description": "The unique identifier of the artist account to fetch social profiles for",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Social profiles retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtistSocialsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtistSocialsErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/artist/socials/scrape": {
      "post": {
        "description": "Trigger scrape jobs for all social profiles linked to an artist. Provide an artist_account_id, and the API will look up the artist's socials and invoke a scraping job for each social profile. Each scrape returns Apify run metadata so you can poll for status and retrieve results.",
        "requestBody": {
          "description": "Artist to scrape socials for",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ArtistSocialsScrapeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scrape jobs triggered successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtistSocialsScrapeResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtistSocialsErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/artist-profile": {
      "get": {
        "description": "Retrieve comprehensive profile information for an artist across all connected social media platforms, including profile details and post metrics.",
        "parameters": [
          {
            "name": "artist_account_id",
            "in": "query",
            "description": "The unique identifier of the artist account to fetch profile data for",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Artist profile retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtistProfileResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtistProfileErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/segment/fans": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Retrieve all social profiles from fans within a specific segment. This endpoint should be called after obtaining segment IDs from the Artist Segments endpoint. Supports pagination for large fan lists.",
        "parameters": [
          {
            "name": "segment_id",
            "in": "query",
            "description": "The unique identifier of the segment to fetch fans for",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "The page number to retrieve (default: 1)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 1
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of records per page (default: 20, max: 100)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "maximum": 100
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Segment fans retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SegmentFansResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SegmentFansErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/fans": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Retrieve all social profiles from fans of an artist across all platforms. This endpoint aggregates fan data from all connected social media platforms. Supports pagination for large fan lists.",
        "parameters": [
          {
            "name": "artist_account_id",
            "in": "query",
            "description": "The unique identifier of the artist account to fetch fans for",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "The page number to retrieve (default: 1)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 1
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of records per page (default: 20, max: 100)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "maximum": 100
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Artist fans retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtistFansResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtistFansErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/posts": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Retrieve all social media posts from an artist across all platforms. This endpoint aggregates posts from all connected social media profiles for the specified artist. Supports pagination for large post collections.",
        "parameters": [
          {
            "name": "artist_account_id",
            "in": "query",
            "description": "The unique identifier of the artist account to fetch posts for",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "The page number to retrieve (default: 1)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 1
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of records per page (default: 20, max: 100)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "maximum": 100
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Artist posts retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtistPostsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtistPostsErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/comments": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Retrieve comments associated with an artist or a specific post, with support for pagination. This endpoint returns raw comment data including the comment text, associated post, and commenter's social profile reference.",
        "parameters": [
          {
            "name": "artist_account_id",
            "in": "query",
            "description": "The unique identifier of the artist account to fetch comments for",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "post_id",
            "in": "query",
            "description": "Filter comments by specific post",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Page number for pagination (default: 1)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 1
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of comments per page (default: 10)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 10
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Comments retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CommentsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CommentsErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/post/comments": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Retrieve comments for a specific social media post. This endpoint should be called after obtaining post IDs from the Social Posts endpoint. Returns detailed information about each commenter including their profile data, follower counts, and geographic region.",
        "parameters": [
          {
            "name": "post_id",
            "in": "query",
            "description": "The unique identifier of the post to fetch comments for",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "The page number to retrieve (default: 1)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 1
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of records per page (default: 20, max: 100)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "maximum": 100
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Post comments retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PostCommentsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PostCommentsErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/chats": {
      "get": {
        "description": "Retrieve chat rooms (conversations) for accounts. For personal API keys, returns chats for the key owner's account. For organization API keys, returns chats for all accounts within the organization. Optionally filter by an artist_account_id. The endpoint returns metadata about each room, including the topic, associated artist, and last updated timestamp.",
        "parameters": [
          {
            "name": "artist_account_id",
            "in": "query",
            "description": "Optional. Filter chats to only include those for the specified artist.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "account_id",
            "in": "query",
            "description": "Filter to a specific account. Only applicable for organization API keys - org keys can filter to any account within their organization. Personal keys cannot use this parameter.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Chats retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetChatsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - invalid query parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetChatsErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - account_id is not a member of the organization or personal key tried to filter by account_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "post": {
        "description": "Create a new chat room. Optionally associate it with an artist and/or provide a client-generated chat ID. Organization API keys can create chats on behalf of other accounts within their organization by specifying an accountId.",
        "requestBody": {
          "description": "Chat creation parameters",
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateChatRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Chat created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateChatResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - failed to create chat",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateChatErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - API key does not have access to the specified accountId",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateChatErrorResponse"
                }
              }
            }
          }
        }
      },
      "patch": {
        "description": "Update a chat room's topic (display name). The chatId is required; the topic field will be updated. Topic must be between 3 and 50 characters.",
        "requestBody": {
          "description": "Chat fields to update",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateChatRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Chat updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateChatResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - invalid parameters or validation error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateChatErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - API key does not have access to this chat",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Not found - chat room does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateChatErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/chats/compact": {
      "post": {
        "description": "Compact one or more chat conversations into summarized versions. This reduces the size of chat history while preserving key information. Optionally provide a prompt to control what information gets preserved in the compacted summary.",
        "requestBody": {
          "description": "Chat compaction parameters",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompactChatsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Chats compacted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CompactChatsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - invalid parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Not found - one or more chat IDs do not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/api/chat/generate": {
      "post": {
        "servers": [
          {
            "url": "https://recoup-api.vercel.app"
          }
        ],
        "description": "Generate AI-powered text responses using the Recoup chat system. This endpoint processes chat requests and returns generated text along with metadata about the generation process.",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "requestBody": {
          "description": "Chat generation request",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatGenerateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Chat generated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatGenerateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatGenerateErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/chat": {
      "post": {
        "servers": [
          {
            "url": "https://recoup-api.vercel.app"
          }
        ],
        "description": "Stream AI-powered chat responses using the Recoup chat system. This endpoint mirrors the request payload of the Chat Generate API but returns a streaming response compatible with the Vercel AI SDK `createUIMessageStreamResponse`. The stream emits UI message parts encoded as data chunks that can be parsed with `createUIMessageStreamParser`.",
        "security": [
          {
            "apiKeyAuth": []
          }
        ],
        "requestBody": {
          "description": "Chat stream request",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatStreamRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Streaming response with UI message parts. Events include: message-start (assistant begins message), message-delta (incremental updates), message-end (assistant finishes message), error (stream error), and metadata (usage data).",
            "content": {
              "text/event-stream": {
                "schema": {
                  "type": "string",
                  "description": "Server-Sent Events stream containing UI message parts"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatStreamErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/organizations": {
      "get": {
        "description": "Retrieve all organizations that an account belongs to. For personal API keys, returns organizations for the key owner's account. For organization API keys, returns organizations for all accounts within the organization.",
        "parameters": [
          {
            "name": "account_id",
            "in": "query",
            "description": "Filter to a specific account. Only applicable for organization API keys - org keys can filter to any account within their organization. Personal keys cannot use this parameter.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Organizations retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetOrganizationsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - invalid query parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationsErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - account_id is not a member of the organization or personal key tried to filter by account_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "post": {
        "description": "Create a new organization. The creator is automatically added as a member of the organization.",
        "requestBody": {
          "description": "Organization creation parameters",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrganizationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Organization created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateOrganizationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationsErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/organizations/artists": {
      "post": {
        "description": "Add an artist to an organization. This allows organization members to access and manage the artist. This endpoint is idempotent - calling it multiple times with the same artistId and organizationId will not create duplicate records.",
        "requestBody": {
          "description": "Artist-organization association parameters",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddArtistToOrganizationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Artist added to organization successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddArtistToOrganizationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationsErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/spotify/search": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Search for artists, albums, tracks, and playlists using the Spotify API. This endpoint is a proxy to the official Spotify Search API.",
        "parameters": [
          {
            "name": "q",
            "in": "query",
            "description": "The search query keywords and optional field filters",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "type",
            "in": "query",
            "description": "A comma-separated list of item types to search across: album, artist, playlist, track, show, episode, audiobook",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "market",
            "in": "query",
            "description": "An ISO 3166-1 alpha-2 country code or 'from_token'",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return (default: 20, min: 1, max: 50)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 1,
              "maximum": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "The index of the first result to return (default: 0, max: 10000)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0,
              "maximum": 10000
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Search results retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpotifySearchResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpotifyErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/spotify/artist/": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Get Spotify catalog information for a single artist identified by their unique Spotify ID.",
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "description": "The Spotify ID of the artist",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Artist retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpotifyGetArtistResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpotifyErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/spotify/artist/albums": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Get Spotify catalog information about an artist's albums.",
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "description": "The Spotify ID of the artist",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "include_groups",
            "in": "query",
            "description": "A comma-separated list of keywords to filter the response. Valid values are: album, single, appears_on, compilation",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "market",
            "in": "query",
            "description": "An ISO 3166-1 alpha-2 country code. If specified, only content available in that market will be returned",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The maximum number of items to return (default: 20, min: 1, max: 50)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 1,
              "maximum": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "The index of the first item to return (default: 0)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Artist albums retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpotifyArtistAlbumsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpotifyErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/spotify/artist/topTracks": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Get an artist's top tracks by country.",
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "description": "The Spotify ID of the artist",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "market",
            "in": "query",
            "description": "An ISO 3166-1 alpha-2 country code. If provided, only tracks available in that market are returned",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Artist top tracks retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpotifyArtistTopTracksResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpotifyErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/spotify/album": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Get Spotify catalog information for a single album.",
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "description": "The Spotify ID of the album",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "market",
            "in": "query",
            "description": "An ISO 3166-1 alpha-2 country code. If provided, only content available in that market is returned",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Album retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpotifyAlbum"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpotifyErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/instagram/comments": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Fetch Instagram comments for multiple post URLs using Apify's Instagram Comment Scraper. The actual comment data will be available in the Apify dataset after the run completes.",
        "parameters": [
          {
            "name": "postUrls",
            "in": "query",
            "description": "Array of Instagram post URLs to fetch comments for",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form",
            "explode": true
          },
          {
            "name": "resultsLimit",
            "in": "query",
            "description": "Maximum number of comments to fetch (default: 10000)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 10000
            }
          },
          {
            "name": "isNewestComments",
            "in": "query",
            "description": "Whether to fetch newest comments first. Set to true for newest first, false for oldest first, or omit for platform default sorting",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Apify scraper run started successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApifyRunResult"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InstagramErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/instagram/profiles": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Fetch Instagram profile information for multiple handles using Apify's Instagram Profile Scraper. The actual profile data will be available in the Apify dataset after the run completes.",
        "parameters": [
          {
            "name": "handles",
            "in": "query",
            "description": "Array of Instagram handles to fetch profiles for",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form",
            "explode": true
          }
        ],
        "responses": {
          "200": {
            "description": "Apify scraper run started successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApifyRunResult"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InstagramErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/apify/scraper": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Check the status and retrieve results from Apify scraper runs. This endpoint uses the Apify API Client to fetch the current status of a scraper run and its results if available. Use the runId returned from endpoints like Instagram Comments, Instagram Profiles, Social Scrape, or Artist Socials Scrape to poll for results.",
        "parameters": [
          {
            "name": "runId",
            "in": "query",
            "description": "The ID of the Apify run to check status for. This is returned when starting a scrape via Instagram Comments, Instagram Profiles, Social Scrape, or Artist Socials Scrape endpoints.",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "abc123xyz"
          }
        ],
        "responses": {
          "200": {
            "description": "Scraper run status retrieved successfully. Returns status info for in-progress runs, or status info plus data for completed runs.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/ApifyScraperInProgressResponse"
                    },
                    {
                      "$ref": "#/components/schemas/ApifyScraperCompletedResponse"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required runId parameter",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApifyScraperErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Server error - failed to fetch run status from Apify",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApifyScraperErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/sandboxes": {
      "get": {
        "description": "List all sandboxes associated with the authenticated account and their current statuses. Returns sandbox details including lifecycle state, timeout remaining, and creation timestamp. For personal API keys, returns sandboxes for the key owner's account. For organization API keys, returns sandboxes for the authenticated account unless account_id is specified. Authentication is handled via the x-api-key header or Authorization Bearer token.",
        "parameters": [
          {
            "name": "sandbox_id",
            "in": "query",
            "required": false,
            "description": "Filter by a specific sandbox ID. When provided, returns only the sandbox matching this ID. Must be a sandbox that your account or organization is an admin of.",
            "schema": {
              "type": "string",
              "example": "sbx_abc123def456"
            }
          },
          {
            "name": "account_id",
            "in": "query",
            "description": "Filter to a specific account. Only applicable for organization API keys - org keys can filter to any account within their organization. Personal keys cannot use this parameter.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Sandboxes retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SandboxesResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SandboxErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - account_id is not a member of the organization or personal key tried to filter by account_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SandboxErrorResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "description": "Create a new ephemeral sandbox environment. Optionally executes a command or an OpenCode prompt if provided. Sandboxes are isolated Linux microVMs that can be used to evaluate account-generated code, run AI agent output safely, or execute reproducible tasks. The sandbox will automatically stop after the timeout period. If no command or prompt is provided, the sandbox is created without triggering any background task. Use the prompt parameter as a shortcut to run `opencode run \"<prompt>\"` in the sandbox. Authentication is handled via the x-api-key header.",
        "requestBody": {
          "description": "Optional command execution parameters. If command and prompt are both omitted, sandbox is created without running any command. Use prompt as a shortcut for running OpenCode.",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateSandboxRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Sandbox created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SandboxesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - failed to create sandbox",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SandboxErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SandboxErrorResponse"
                }
              }
            }
          }
        }
      },
      "patch": {
        "description": "Set a custom snapshot ID for an account. For personal API keys, this updates the key owner's account. Organization API keys may specify account_id to target any account within their organization. This allows accounts to use a specific sandbox snapshot when creating new sandboxes, enabling reproducible environments with pre-configured tools, dependencies, and files.",
        "requestBody": {
          "description": "Snapshot configuration parameters",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateSnapshotRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Snapshot ID updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateSnapshotResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - invalid snapshot ID",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SandboxErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SandboxErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - account_id is not a member of the organization or personal key tried to use account_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SandboxErrorResponse"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Delete a sandbox environment for the authenticated account. This permanently deletes the associated GitHub repository and removes the account's snapshot record from the database. For personal API keys, deletes the sandbox for the key owner's account. Organization API keys may specify account_id to target any account within their organization. Authentication is handled via the x-api-key header or Authorization Bearer token.",
        "requestBody": {
          "description": "Optional account targeting parameters",
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteSandboxRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Sandbox deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteSandboxResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - failed to delete sandbox",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SandboxErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SandboxErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - account_id is not a member of the organization or personal key tried to use account_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SandboxErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/sandboxes/setup": {
      "post": {
        "description": "Triggers the setup-sandbox background task to create a personal sandbox, provision a GitHub repo, take a snapshot, and shut down. For personal API keys, sets up the sandbox for the key owner's account. Organization API keys may specify account_id to target any account within their organization. Authentication is handled via the x-api-key header or Authorization Bearer token.",
        "requestBody": {
          "description": "Optional account targeting parameters",
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetupSandboxRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Setup task triggered successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SetupSandboxResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - invalid account_id format",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SandboxErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SandboxErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/x/search": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Search for tweets using the Twitter Search API, powered by agent-twitter-client (no Twitter API key required). Supports various search modes including Top, Latest, Photos, Videos, and Users.",
        "parameters": [
          {
            "name": "query",
            "in": "query",
            "description": "The search query. Any Twitter-compatible query format can be used (e.g., '#nodejs', 'from:username', etc.)",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "maxTweets",
            "in": "query",
            "description": "The maximum number of tweets to return",
            "required": true,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "searchMode",
            "in": "query",
            "description": "The category filter to apply to the search",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["Top", "Latest", "Photos", "Videos", "Users"],
              "default": "Latest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Tweets retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TwitterSearchResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TwitterErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/x/trends": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Retrieve the current trending topics from Twitter using the getTrends method from agent-twitter-client (no Twitter API key required).",
        "responses": {
          "200": {
            "description": "Trends retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TwitterTrendsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TwitterErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/social/scrape": {
      "post": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Trigger a social profile scraping job for a given social_id. Use the Get Artist Socials endpoint first to retrieve the social_id values. The response returns Apify run metadata for polling status and retrieving results via the Apify Scraper Results API.",
        "requestBody": {
          "description": "Social profile to scrape",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SocialScrapeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scrape job triggered successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApifyRunResult"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SocialErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/social/posts": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Retrieve all social media posts from a specific social profile. Call the Artist Socials endpoint first to obtain social IDs.",
        "parameters": [
          {
            "name": "social_id",
            "in": "query",
            "description": "The unique identifier (UUID) of the social profile to fetch posts for",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "latestFirst",
            "in": "query",
            "description": "Sort posts by most recent first (default: true)",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "The page number to retrieve (default: 1)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 1
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of records per page (default: 20, max: 100)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "maximum": 100
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Posts retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SocialPostsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SocialErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/image/generate": {
      "get": {
        "servers": [
          {
            "url": "https://recoup-api.vercel.app"
          }
        ],
        "description": "Generate high-quality images using AI models. Images are automatically stored on Arweave and include In Process moment metadata for provenance and ownership tracking.",
        "parameters": [
          {
            "name": "prompt",
            "in": "query",
            "description": "Text description of the image you want to generate",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "account_id",
            "in": "query",
            "description": "The unique identifier of the account generating the image",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Image generated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ImageGenerationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required parameters or invalid input",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ImageGenerationErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/transcribe": {
      "post": {
        "description": "Transcribe audio files using OpenAI Whisper. The API saves both the original audio file and the generated markdown transcript to the customer's files in Supabase Storage.",
        "requestBody": {
          "description": "Audio transcription request",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TranscribeAudioRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Audio transcribed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TranscribeAudioResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required fields or invalid audio URL",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TranscribeAudioErrorResponse"
                }
              }
            }
          },
          "413": {
            "description": "Audio file exceeds the 25MB limit",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TranscribeAudioErrorResponse"
                }
              }
            }
          },
          "429": {
            "description": "Rate limit exceeded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TranscribeAudioErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Server error - OpenAI API key not configured",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TranscribeAudioErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/songs": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Retrieve songs from the database with optional filtering by ISRC (International Standard Recording Code) or artist account. This endpoint joins the songs table with song_artists and accounts tables to provide comprehensive song information.",
        "parameters": [
          {
            "name": "isrc",
            "in": "query",
            "description": "International Standard Recording Code to filter by specific song",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "artist_account_id",
            "in": "query",
            "description": "Artist account ID to filter songs by artist",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Songs retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SongsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - invalid parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SongsErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "No songs found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SongsErrorResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Bulk create or fetch songs by ISRC. For each song, the API attempts to look up metadata via internal search. If no data is found, optional fallback fields (name, album, notes, artists) are used.",
        "requestBody": {
          "description": "Array of songs to create or fetch",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateSongsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Songs created or fetched successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SongsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - invalid parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SongsErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/catalogs": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Retrieve catalogs associated with a specific account. The endpoint joins account_catalogs with catalogs to return catalog metadata for the specified account.",
        "parameters": [
          {
            "name": "account_id",
            "in": "query",
            "description": "The unique identifier of the account to query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Catalogs retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing or invalid account_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogsErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Account not found or no catalogs found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogsErrorResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Create new catalogs or link existing catalogs to an account. If catalog_id is provided, links the existing catalog. If name is provided without catalog_id, creates a new catalog. If both are provided, catalog_id takes priority.",
        "requestBody": {
          "description": "Array of catalogs to create or link",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateCatalogsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Catalogs created or linked successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - invalid parameters or catalog_id not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogsErrorResponse"
                }
              }
            }
          }
        }
      },
      "delete": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Unlink catalogs from an account. If no other accounts are linked to a catalog after removal, the catalog is automatically deleted (cascading to catalog_songs). Otherwise, only the account-catalog relationship is removed.",
        "requestBody": {
          "description": "Array of catalog-account pairs to remove",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteCatalogsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Catalogs unlinked successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing catalog_id or account_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogsErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/catalogs/songs": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Retrieve songs within a specific catalog with pagination support. This endpoint joins catalog_songs with songs, song_artists, and accounts to provide comprehensive song information for a given catalog.",
        "parameters": [
          {
            "name": "catalog_id",
            "in": "query",
            "description": "The unique identifier of the catalog to query songs for",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "artistName",
            "in": "query",
            "description": "Optional. Filters songs to only include those with matching artist name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Page number for pagination (default: 1)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 1
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of songs per page (default: 20, max: 100)",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "maximum": 100
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Catalog songs retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogSongsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing or invalid catalog_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogSongsErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Catalog not found or no songs in catalog",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogSongsErrorResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Batch add songs to a catalog by ISRC. For each song, the API attempts to look up metadata via internal search. If no data is found, optional fallback fields (name, album, notes, artists) are used.",
        "requestBody": {
          "description": "Array of songs to add to catalog",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddCatalogSongsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Songs added to catalog successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogSongsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing required fields",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogSongsErrorResponse"
                }
              }
            }
          }
        }
      },
      "delete": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Batch remove songs from a catalog by ISRC. Deletes the relationship in catalog_songs for each catalog_id and ISRC pair.",
        "requestBody": {
          "description": "Array of songs to remove from catalog",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteCatalogSongsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Songs removed from catalog successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogSongsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing catalog_id or isrc",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogSongsErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/subscriptions": {
      "get": {
        "servers": [
          {
            "url": "https://api.recoupable.com"
          }
        ],
        "description": "Retrieve subscription information for an account. For accounts with enterprise plans, returns a simplified response indicating enterprise status. For standard accounts, returns the full Stripe subscription object.",
        "parameters": [
          {
            "name": "accountId",
            "in": "query",
            "description": "The unique identifier of the account to query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Subscription information retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/SubscriptionResponse"
                    },
                    {
                      "$ref": "#/components/schemas/EnterpriseSubscriptionResponse"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing or invalid accountId",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Account not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/workspaces": {
      "post": {
        "description": "Create a new workspace account. Workspaces can optionally be linked to an organization.",
        "requestBody": {
          "description": "Workspace creation parameters",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateWorkspaceRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Workspace created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateWorkspaceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - validation error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing authentication",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - access denied to organization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/api/pulses": {
      "get": {
        "description": "Retrieve pulse information for accounts. For personal API keys, returns an array with a single pulse for the key owner's account. For organization API keys, returns pulses for all accounts within the organization.",
        "parameters": [
          {
            "name": "account_id",
            "in": "query",
            "description": "Filter to a specific account. Only applicable for organization API keys - org keys can filter to any account within their organization. Personal keys cannot use this parameter.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "active",
            "in": "query",
            "description": "Filter by active status. Set to 'true' to return only active pulses, 'false' for inactive pulses. If not provided, returns all pulses regardless of active status.",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["true", "false"]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Pulses retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PulsesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - invalid query parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - account_id is not a member of the organization or personal key tried to filter by account_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "patch": {
        "description": "Update the pulse settings for an account. Use this to enable or disable the pulse. Returns an array of pulses for consistency with the GET endpoint.",
        "requestBody": {
          "description": "Pulse fields to update",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdatePulseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Pulse updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PulsesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/api/connectors": {
      "get": {
        "description": "List available connectors and their connection status. Returns all supported third-party integrations (e.g., Google Sheets, TikTok) along with whether they are currently connected.",
        "parameters": [
          {
            "name": "account_id",
            "in": "query",
            "description": "Optional account ID to get connectors for a different account (e.g., an artist, workspace, or organization). The authenticated account must have access to the specified account. Omit to get your own account's connectors.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Connectors retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConnectorsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - invalid account_id format",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - no access to the specified account",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Disconnect a connected account from a third-party service. This revokes the OAuth connection and removes stored credentials.",
        "requestBody": {
          "description": "Connection to disconnect",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DisconnectConnectorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Connector disconnected successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DisconnectConnectorResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing or invalid parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - no access to the specified account or connection",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "post": {
        "description": "Generate an OAuth authorization URL for connecting a third-party service. Redirect to the returned URL to complete the OAuth flow.",
        "requestBody": {
          "description": "Authorization request details",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthorizeConnectorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Authorization URL generated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthorizeConnectorResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - invalid connector or parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - no access to the specified account",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/api/video/render": {
      "post": {
        "description": "Trigger a server-side video render. Returns a run ID that can be polled via [GET /api/tasks/runs](/api-reference/tasks/runs) to check status and retrieve the rendered video URL when complete. Authentication is handled via the x-api-key header or Authorization Bearer token.",
        "requestBody": {
          "description": "Video render configuration including the composition ID, input props, and output settings",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RenderVideoRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Render task triggered successfully. Use the returned runId with [GET /api/tasks/runs](/api-reference/tasks/runs) to poll for completion.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RenderVideoResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - missing or invalid fields",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RenderVideoErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RenderVideoErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Server error - failed to trigger render task",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RenderVideoErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/content/create": {
      "post": {
        "description": "Trigger the content creation pipeline for an artist. Provide either `artist_account_id` or `artist_slug` to identify the target artist. Validates the artist has all required files (face guide, songs, config), then triggers a background task that generates a short-form video. Returns a run ID that can be polled via [GET /api/tasks/runs](/api-reference/tasks/runs) to check progress and retrieve the output video path when complete. Authentication is handled via the x-api-key header.",
        "requestBody": {
          "description": "Content creation parameters including the target artist and optional template/workflow settings",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ContentCreateRequest"
              }
            }
          }
        },
        "responses": {
          "202": {
            "description": "Pipeline triggered successfully. Use the returned runId with [GET /api/tasks/runs](/api-reference/tasks/runs) to poll for progress.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentCreateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Validation failed  missing artist identifier, artist is missing required files, or template not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentCreateErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized  invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden  account_id is not a member of the organization or personal key tried to use account_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Artist not found  the provided artist_account_id or artist_slug does not match any artist for this account",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/content/templates": {
      "get": {
        "description": "List all available content creation templates. Templates define the visual style, scene composition, and default workflow settings for generated videos. Each template includes reference images, style guides, caption rules, and prompt configurations.",
        "responses": {
          "200": {
            "description": "Templates retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentTemplatesResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized  invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/content/validate": {
      "get": {
        "description": "Check whether an artist has all the required files to run the content creation pipeline. Returns a structured report of each required and recommended file with its status. Required files must be present or the pipeline will fail. Recommended files improve output quality but are not strictly necessary. Provide either `artist_account_id` or `artist_slug`  at least one is required.",
        "parameters": [
          {
            "name": "artist_account_id",
            "in": "query",
            "description": "UUID of the artist account to validate. Use [GET /api/artists](/api-reference/artists/list) to find artist account IDs.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid",
              "example": "1873859c-dd37-4e9a-9bac-80d3558527a9"
            }
          },
          {
            "name": "artist_slug",
            "in": "query",
            "description": "The artist directory name (slug) as an alternative to `artist_account_id`. Must match a directory under `artists/` in the account's GitHub repository.",
            "required": false,
            "schema": {
              "type": "string",
              "example": "gatsby-grace"
            }
          },
          {
            "name": "account_id",
            "in": "query",
            "description": "UUID of the account that owns the artist. Only applicable for organization API keys  org keys can specify an account_id for any account within their organization. If not provided, uses the API key's own account.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid",
              "example": "550e8400-e29b-41d4-a716-446655440000"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Validation completed. Check the `ready` field to determine if the artist can run the pipeline.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentValidateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request  must provide either artist_account_id or artist_slug",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized  invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden  account_id is not a member of the organization or personal key tried to use account_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Artist not found  the provided artist_account_id or artist_slug does not match any artist for this account",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/content/estimate": {
      "get": {
        "description": "Estimate the cost of running the content creation pipeline. Fetches live pricing from fal.ai and calculates per-step and per-video costs. Supports comparing multiple workflow profiles (e.g., premium vs. budget) and projecting batch costs. This endpoint is informational only  it does not trigger any pipeline execution or spend credits.",
        "parameters": [
          {
            "name": "lipsync",
            "in": "query",
            "description": "Which workflow to estimate. `false` for image-to-video, `true` for audio-to-video. If omitted, estimates the default image-to-video workflow.",
            "required": false,
            "schema": {
              "type": "boolean",
              "example": false
            }
          },
          {
            "name": "batch",
            "in": "query",
            "description": "Number of videos to project costs for. Use this to answer questions like \"how much would 30 videos cost?\"",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "default": 1,
              "example": 1
            }
          },
          {
            "name": "compare",
            "in": "query",
            "description": "When `true`, returns estimates for all available workflow profiles (premium, budget, mid) for side-by-side comparison.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "example": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Cost estimate calculated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentEstimateResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized  invalid or missing API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/songs/analyze/presets": {
      "get": {
        "description": "Lists all available music analysis presets. Each preset is a curated prompt with optimized generation parameters for a specific use case (e.g. catalog metadata enrichment, sync licensing analysis, audience profiling). No authentication required.",
        "responses": {
          "200": {
            "description": "Presets listed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": ["success"]
                    },
                    "presets": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "name": {
                            "type": "string",
                            "description": "Preset identifier to pass in the analyze request"
                          },
                          "label": {
                            "type": "string",
                            "description": "Human-readable preset name"
                          },
                          "description": {
                            "type": "string",
                            "description": "What this preset does"
                          },
                          "requiresAudio": {
                            "type": "boolean",
                            "description": "Whether this preset needs an audio_url"
                          },
                          "responseFormat": {
                            "type": "string",
                            "enum": ["json", "text"],
                            "description": "Expected response format"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/songs/analyze": {
      "post": {
        "description": "Analyze music using a state-of-the-art Audio Language Model that listens directly to the audio waveform. Unlike text-based AI, this model processes the actual sound  identifying harmony, structure, timbre, lyrics, and cultural context through deep music understanding. Supports audio up to 20 minutes (MP3, WAV, FLAC). Two modes: (1) **Presets**  pass a `preset` name like `catalog_metadata`, `mood_tags`, or `full_report` for structured, optimized output. (2) **Custom prompt**  pass a `prompt` for free-form questions. The `full_report` preset runs all 13 presets in parallel and returns a comprehensive music intelligence report. Use `GET /api/songs/analyze/presets` to list available presets.",
        "requestBody": {
          "description": "Music analysis request",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SongAnalyzeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Music analysis completed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SongAnalyzeResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request  missing or invalid fields",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SongAnalyzeErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized  invalid or missing API key / Bearer token",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SongAnalyzeErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Server error  upstream model unavailable or inference failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SongAnalyzeErrorResponse"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "Error": {
        "required": [
          "error",
          "message"
        ],
        "type": "object",
        "properties": {
          "error": {
            "type": "integer",
            "format": "int32"
          },
          "message": {
            "type": "string"
          }
        }
      },
      "ConnectorInfo": {
        "type": "object",
        "required": ["slug", "name", "isConnected"],
        "properties": {
          "slug": {
            "type": "string",
            "description": "Unique identifier for the connector (e.g., 'googlesheets', 'tiktok')"
          },
          "name": {
            "type": "string",
            "description": "Human-readable name of the connector"
          },
          "isConnected": {
            "type": "boolean",
            "description": "Whether the connector is currently connected"
          },
          "connectedAccountId": {
            "type": "string",
            "description": "The connected account ID (only present when isConnected is true)"
          }
        }
      },
      "ConnectorsResponse": {
        "type": "object",
        "required": ["success", "connectors"],
        "properties": {
          "success": {
            "type": "boolean"
          },
          "connectors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConnectorInfo"
            },
            "description": "List of available connectors with connection status"
          }
        }
      },
      "AuthorizeConnectorRequest": {
        "type": "object",
        "required": ["connector"],
        "properties": {
          "connector": {
            "type": "string",
            "description": "The connector slug to authorize (e.g., 'googlesheets', 'tiktok')"
          },
          "callback_url": {
            "type": "string",
            "format": "uri",
            "description": "Optional custom callback URL after OAuth completion"
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "Optional account ID to connect a service for a different account (e.g., an artist, workspace, or organization). Use this when connecting an artist's TikTok or other service. The authenticated account must have access. Omit to connect for your own account."
          }
        }
      },
      "AuthorizeConnectorResponse": {
        "type": "object",
        "required": ["success", "data"],
        "properties": {
          "success": {
            "type": "boolean"
          },
          "data": {
            "type": "object",
            "required": ["connector", "redirectUrl"],
            "properties": {
              "connector": {
                "type": "string",
                "description": "The connector slug being authorized"
              },
              "redirectUrl": {
                "type": "string",
                "format": "uri",
                "description": "URL to redirect to for OAuth authorization"
              }
            }
          }
        }
      },
      "DisconnectConnectorRequest": {
        "type": "object",
        "required": ["connected_account_id"],
        "properties": {
          "connected_account_id": {
            "type": "string",
            "description": "The connected account ID to disconnect (from ConnectorInfo.connectedAccountId)"
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "Optional account ID when disconnecting a connection that belongs to a different account (e.g., an artist). Required when the connection was created for another account rather than your own. The authenticated account must have access."
          }
        }
      },
      "DisconnectConnectorResponse": {
        "type": "object",
        "required": ["success"],
        "properties": {
          "success": {
            "type": "boolean"
          },
          "message": {
            "type": "string",
            "description": "Status message"
          }
        }
      },
      "CompactChatsRequest": {
        "type": "object",
        "required": ["chatId"],
        "properties": {
          "chatId": {
            "type": "array",
            "minItems": 1,
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Array of chat IDs to compact"
          },
          "prompt": {
            "type": "string",
            "description": "Optional prompt to control what information gets preserved in the compacted summary"
          }
        }
      },
      "CompactChatsResponse": {
        "type": "object",
        "required": ["chats"],
        "properties": {
          "chats": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CompactedChat"
            },
            "description": "Array of compacted chat results"
          }
        }
      },
      "CompactedChat": {
        "type": "object",
        "required": ["chatId", "compacted"],
        "properties": {
          "chatId": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the chat that was compacted"
          },
          "compacted": {
            "type": "string",
            "description": "The compacted summary text of the chat"
          }
        }
      },
      "TasksResponse": {
        "type": "object",
        "required": ["status", "tasks"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success", "error"],
            "description": "Status of the request"
          },
          "tasks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Task"
            },
            "description": "Array of task objects"
          },
          "error": {
            "type": "string",
            "description": "Error message (only present if status is error)"
          }
        }
      },
      "Task": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the task"
          },
          "title": {
            "type": "string",
            "description": "Descriptive title or name of the task"
          },
          "prompt": {
            "type": "string",
            "description": "Detailed instruction or prompt for task execution"
          },
          "schedule": {
            "type": "string",
            "description": "Cron expression defining when the task should execute (e.g., '0 10 * * *')"
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the associated account"
          },
          "artist_account_id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the associated artist account"
          },
          "enabled": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether the task is enabled. Defaults to true."
          },
          "trigger_schedule_id": {
            "type": "string",
            "nullable": true,
            "description": "Identifier for the trigger schedule associated with this task"
          }
        }
      },
      "CreateTaskRequest": {
        "type": "object",
        "required": ["title", "prompt", "schedule", "account_id", "artist_account_id"],
        "properties": {
          "title": {
            "type": "string",
            "description": "Descriptive title of the task",
            "example": "Weekly Genre Pulse Check"
          },
          "prompt": {
            "type": "string",
            "description": "Instruction/prompt executed by the task",
            "example": "Execute this weekly genre analysis workflow and email a summary to the team."
          },
          "schedule": {
            "type": "string",
            "description": "Cron expression defining when the task runs (e.g., '0 9 * * 4' for Thursdays at 9 AM)",
            "example": "0 9 * * 4"
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the associated account",
            "example": "848cd58d-700f-4b38-ab4c-d9f52a1b2c3d"
          },
          "artist_account_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the associated artist account",
            "example": "1873859c-dd37-4e9a-9bac-80d35a1b2c3d"
          }
        }
      },
      "UpdateTaskRequest": {
        "type": "object",
        "required": ["id"],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the task to update",
            "example": "aade2bce-55c7-468e-a606-c4e76fb2ea2a"
          },
          "title": {
            "type": "string",
            "description": "New descriptive title of the task",
            "example": "Weekly Genre Pulse Check (Updated)"
          },
          "prompt": {
            "type": "string",
            "description": "New instruction/prompt executed by the task",
            "example": "Execute this weekly genre analysis workflow and email a summary to the team."
          },
          "schedule": {
            "type": "string",
            "description": "New cron expression defining when the task runs",
            "example": "0 10 * * 4"
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "New UUID of the associated account",
            "example": "848cd58d-700f-4b38-ab4c-d9f52a1b2c3d"
          },
          "artist_account_id": {
            "type": "string",
            "format": "uuid",
            "description": "New UUID of the associated artist account",
            "example": "1873859c-dd37-4e9a-9bac-80d35a1b2c3d"
          },
          "enabled": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether the task is enabled. Can be true, false, or null.",
            "example": true
          }
        }
      },
      "DeleteTaskRequest": {
        "type": "object",
        "required": ["id"],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the task to delete",
            "example": "aade2bce-55c7-468e-a606-c4e76fb2ea2a"
          }
        }
      },
      "DeleteTaskResponse": {
        "type": "object",
        "required": ["status"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success", "error"],
            "description": "Status of the delete operation"
          },
          "error": {
            "type": "string",
            "description": "Error message (only present if status is error)"
          }
        }
      },
      "Account": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the account"
          },
          "name": {
            "type": "string",
            "description": "Account display name"
          },
          "image": {
            "type": "string",
            "nullable": true,
            "description": "Profile image URL"
          },
          "instruction": {
            "type": "string",
            "nullable": true,
            "description": "Custom AI instructions for this account"
          },
          "knowledges": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/Knowledge"
            },
            "description": "Knowledge base files attached to this account"
          },
          "email": {
            "type": "string",
            "nullable": true,
            "description": "Primary email address"
          },
          "wallet_address": {
            "type": "string",
            "nullable": true,
            "description": "Connected wallet address"
          }
        }
      },
      "Knowledge": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "URL to the knowledge file"
          },
          "name": {
            "type": "string",
            "description": "Name of the knowledge file"
          },
          "type": {
            "type": "string",
            "description": "MIME type of the file"
          }
        }
      },
      "GetAccountResponse": {
        "type": "object",
        "required": ["status", "account"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "account": {
            "$ref": "#/components/schemas/Account",
            "description": "The account details"
          }
        }
      },
      "GetAccountIdResponse": {
        "type": "object",
        "required": ["status", "accountId"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "The unique identifier (UUID) of the authenticated account"
          }
        }
      },
      "AccountErrorResponse": {
        "type": "object",
        "required": ["status", "message"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "message": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "CreateAccountRequest": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "description": "Email address to associate with the account. If an account with this email exists, it will be returned."
          },
          "wallet": {
            "type": "string",
            "description": "Wallet address to associate with the account. If an account with this wallet exists, it will be returned."
          }
        },
        "description": "At least one of email or wallet should be provided to identify or create an account."
      },
      "UpdateAccountRequest": {
        "type": "object",
        "required": ["accountId"],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "The unique identifier of the account to update"
          },
          "name": {
            "type": "string",
            "description": "Display name for the account"
          },
          "instruction": {
            "type": "string",
            "description": "Custom instruction or bio for the account"
          },
          "organization": {
            "type": "string",
            "description": "Organization name associated with the account"
          },
          "image": {
            "type": "string",
            "format": "uri",
            "description": "URL of the account's profile image"
          },
          "jobTitle": {
            "type": "string",
            "description": "Job title of the account holder"
          },
          "roleType": {
            "type": "string",
            "description": "Role type within the organization"
          },
          "companyName": {
            "type": "string",
            "description": "Company name associated with the account"
          },
          "knowledges": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of knowledge areas or expertise"
          }
        }
      },
      "AddArtistToAccountRequest": {
        "type": "object",
        "required": ["email", "artistId"],
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "description": "Email address of the account to add the artist to"
          },
          "artistId": {
            "type": "string",
            "format": "uuid",
            "description": "The unique identifier of the artist to add"
          }
        }
      },
      "AccountDataResponse": {
        "type": "object",
        "required": ["data"],
        "properties": {
          "data": {
            "$ref": "#/components/schemas/AccountData",
            "description": "The account data"
          }
        }
      },
      "AccountData": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "The unique identifier of the account"
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "The account ID (same as id, for consistency)"
          },
          "name": {
            "type": "string",
            "description": "Display name of the account"
          },
          "email": {
            "type": "string",
            "format": "email",
            "description": "Email address associated with the account"
          },
          "wallet": {
            "type": "string",
            "description": "Wallet address associated with the account"
          },
          "image": {
            "type": "string",
            "format": "uri",
            "description": "URL of the account's profile image"
          },
          "instruction": {
            "type": "string",
            "description": "Custom instruction or bio"
          },
          "organization": {
            "type": "string",
            "description": "Organization name"
          },
          "job_title": {
            "type": "string",
            "description": "Job title"
          },
          "role_type": {
            "type": "string",
            "description": "Role type"
          },
          "company_name": {
            "type": "string",
            "description": "Company name"
          },
          "knowledges": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of knowledge areas"
          }
        }
      },
      "AddArtistSuccessResponse": {
        "type": "object",
        "required": ["success"],
        "properties": {
          "success": {
            "type": "boolean",
            "enum": [true],
            "description": "Indicates the artist was successfully added"
          }
        }
      },
      "Artist": {
        "type": "object",
        "properties": {
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the artist account"
          },
          "name": {
            "type": "string",
            "description": "Artist display name"
          },
          "image": {
            "type": "string",
            "nullable": true,
            "description": "Artist profile image URL"
          },
          "pinned": {
            "type": "boolean",
            "description": "Whether the account has pinned this artist"
          },
          "socials": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ArtistSocial"
            },
            "description": "Social media profiles linked to the artist"
          }
        }
      },
      "ArtistSocial": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the social profile"
          },
          "platform": {
            "type": "string",
            "description": "Social media platform (e.g., instagram, twitter, tiktok)"
          },
          "username": {
            "type": "string",
            "description": "Username on the platform"
          },
          "profile_url": {
            "type": "string",
            "description": "Full URL to the social media profile"
          }
        }
      },
      "ArtistsResponse": {
        "type": "object",
        "required": ["status", "artists"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success", "error"],
            "description": "Status of the request"
          },
          "artists": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Artist"
            },
            "description": "List of artist objects"
          },
          "message": {
            "type": "string",
            "description": "Error message (only present if status is error)"
          }
        }
      },
      "ArtistsErrorResponse": {
        "type": "object",
        "required": ["status", "message"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "message": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "CreateArtistRequest": {
        "type": "object",
        "required": ["name"],
        "properties": {
          "name": {
            "type": "string",
            "minLength": 1,
            "description": "The name of the artist to create"
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the account to create the artist for. Only applicable for organization API keys - org keys can specify an account_id for any account within their organization. If not provided, the artist is created for the API key's own account."
          },
          "organization_id": {
            "type": "string",
            "format": "uuid",
            "description": "Optional organization ID to link the new artist to"
          }
        }
      },
      "CreateArtistResponse": {
        "type": "object",
        "required": ["artist"],
        "properties": {
          "artist": {
            "$ref": "#/components/schemas/CreatedArtist"
          }
        }
      },
      "CreatedArtist": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the created artist account"
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the artist account (same as id)"
          },
          "name": {
            "type": "string",
            "description": "Name of the artist"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "ISO timestamp of when the artist was created"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "ISO timestamp of when the artist was last updated"
          },
          "image": {
            "type": "string",
            "nullable": true,
            "description": "Artist profile image URL"
          },
          "instruction": {
            "type": "string",
            "nullable": true,
            "description": "Custom AI instruction for this artist"
          },
          "knowledges": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Knowledge base references for this artist"
          },
          "label": {
            "type": "string",
            "nullable": true,
            "description": "Record label name"
          },
          "organization": {
            "type": "string",
            "nullable": true,
            "description": "Organization name"
          },
          "company_name": {
            "type": "string",
            "nullable": true,
            "description": "Company name"
          },
          "job_title": {
            "type": "string",
            "nullable": true,
            "description": "Job title"
          },
          "role_type": {
            "type": "string",
            "nullable": true,
            "description": "Role type"
          },
          "onboarding_status": {
            "type": "string",
            "nullable": true,
            "description": "Onboarding status"
          },
          "onboarding_data": {
            "nullable": true,
            "description": "Onboarding data"
          },
          "account_info": {
            "type": "array",
            "description": "Account info records"
          },
          "account_socials": {
            "type": "array",
            "description": "Linked social media accounts"
          }
        }
      },
      "CreateArtistError": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "missing_fields": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of missing or invalid field names"
          },
          "error": {
            "type": "string",
            "description": "Error message describing the validation failure"
          },
          "message": {
            "type": "string",
            "description": "Error message (for invalid JSON or other errors)"
          }
        }
      },
      "ArtistSegment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the artist_segments record"
          },
          "artist_account_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the artist's accounts record"
          },
          "segment_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the segments record"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of when the segment data was last updated"
          },
          "segment_name": {
            "type": "string",
            "description": "Name of the segment (e.g., 'Twitter Followers')"
          },
          "artist_name": {
            "type": "string",
            "description": "Name of the artist"
          }
        }
      },
      "ArtistSegmentsPagination": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "integer",
            "description": "Total number of segments available"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "limit": {
            "type": "integer",
            "description": "Number of segments per page"
          },
          "total_pages": {
            "type": "integer",
            "description": "Total number of pages available"
          }
        }
      },
      "ArtistSegmentsResponse": {
        "type": "object",
        "required": ["status", "segments", "pagination"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "segments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ArtistSegment"
            },
            "description": "List of segment objects associated with the artist"
          },
          "pagination": {
            "$ref": "#/components/schemas/ArtistSegmentsPagination",
            "description": "Pagination metadata for the response"
          }
        }
      },
      "ArtistSegmentsErrorResponse": {
        "type": "object",
        "required": ["status", "message"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "message": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "SocialProfile": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the artist's account_socials record"
          },
          "social_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the artist's socials account"
          },
          "username": {
            "type": "string",
            "description": "Username on the platform"
          },
          "profile_url": {
            "type": "string",
            "description": "Direct URL to the profile"
          },
          "avatar": {
            "type": "string",
            "nullable": true,
            "description": "URL to the profile avatar image"
          },
          "bio": {
            "type": "string",
            "nullable": true,
            "description": "Profile biography or description"
          },
          "follower_count": {
            "type": "integer",
            "nullable": true,
            "description": "Number of followers on this platform"
          },
          "following_count": {
            "type": "integer",
            "nullable": true,
            "description": "Number of accounts followed on this platform"
          },
          "region": {
            "type": "string",
            "nullable": true,
            "description": "Geographic region of the profile"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of when the profile was last updated"
          }
        }
      },
      "ArtistSocialsPagination": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "integer",
            "description": "Total number of social profiles available"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "limit": {
            "type": "integer",
            "description": "Number of social profiles per page"
          },
          "total_pages": {
            "type": "integer",
            "description": "Total number of pages available"
          }
        }
      },
      "ArtistSocialsResponse": {
        "type": "object",
        "required": ["status", "socials", "pagination"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "socials": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SocialProfile"
            },
            "description": "List of social media profiles associated with the artist"
          },
          "pagination": {
            "$ref": "#/components/schemas/ArtistSocialsPagination",
            "description": "Pagination metadata for the response"
          }
        }
      },
      "ArtistSocialsErrorResponse": {
        "type": "object",
        "required": ["status", "message"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "message": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "ArtistSocialsScrapeRequest": {
        "type": "object",
        "required": ["artist_account_id"],
        "properties": {
          "artist_account_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the artist account to scrape socials for",
            "example": "1873859c-dd37-4e9a-9bac-80d35a1b2c3d"
          }
        }
      },
      "ApifyRunResult": {
        "type": "object",
        "properties": {
          "runId": {
            "type": "string",
            "description": "Unique identifier for the Apify run"
          },
          "datasetId": {
            "type": "string",
            "description": "Unique identifier for the dataset containing scraped data"
          },
          "error": {
            "type": "string",
            "nullable": true,
            "description": "Error message if the run failed (null if successful)"
          }
        }
      },
      "InstagramErrorResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "message": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "ApifyScraperInProgressResponse": {
        "type": "object",
        "required": ["status", "datasetId"],
        "description": "Response when the Apify run is still in progress",
        "properties": {
          "status": {
            "type": "string",
            "description": "Current status of the Apify run (e.g., 'RUNNING', 'READY')",
            "example": "RUNNING"
          },
          "datasetId": {
            "type": "string",
            "description": "ID of the dataset that will contain the results when the run completes",
            "example": "def456uvw"
          }
        }
      },
      "ApifyScraperCompletedResponse": {
        "type": "object",
        "required": ["status", "datasetId", "data"],
        "description": "Response when the Apify run has completed successfully",
        "properties": {
          "status": {
            "type": "string",
            "description": "Final status of the Apify run (typically 'SUCCEEDED')",
            "example": "SUCCEEDED"
          },
          "datasetId": {
            "type": "string",
            "description": "ID of the dataset containing the results",
            "example": "def456uvw"
          },
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": true
            },
            "description": "Array of dataset items returned by the scraper. The structure of each item varies depending on the scraper type (Instagram Profile, Instagram Comments, etc.)",
            "example": [
              {
                "id": "123456789",
                "username": "example_user",
                "fullName": "Example User",
                "biography": "This is a sample biography",
                "followersCount": 1000,
                "followsCount": 500,
                "profilePicUrl": "https://example.com/profile.jpg"
              }
            ]
          }
        }
      },
      "ApifyScraperErrorResponse": {
        "type": "object",
        "required": ["status", "message"],
        "description": "Error response from the Apify scraper results endpoint",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status indicating an error occurred"
          },
          "message": {
            "type": "string",
            "description": "Error message describing what went wrong",
            "example": "runId is required"
          }
        }
      },
      "ArtistSocialsScrapeResponse": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/ApifyRunResult"
        },
        "description": "Array of Apify run results, one for each social profile scraped"
      },
      "ArtistProfileSocialProfile": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the social profile"
          },
          "username": {
            "type": "string",
            "description": "Username on the platform"
          },
          "profile_url": {
            "type": "string",
            "description": "Direct URL to the profile"
          },
          "avatar": {
            "type": "string",
            "nullable": true,
            "description": "URL to the profile avatar image"
          },
          "bio": {
            "type": "string",
            "nullable": true,
            "description": "Profile biography or description"
          },
          "follower_count": {
            "type": "integer",
            "nullable": true,
            "description": "Number of followers on this platform"
          },
          "following_count": {
            "type": "integer",
            "nullable": true,
            "description": "Number of accounts followed on this platform"
          },
          "post_count": {
            "type": "integer",
            "nullable": true,
            "description": "Number of posts on this platform"
          },
          "region": {
            "type": "string",
            "nullable": true,
            "description": "Geographic region of the profile"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of when the profile was last updated"
          }
        }
      },
      "ArtistProfile": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the artist"
          },
          "profiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ArtistProfileSocialProfile"
            },
            "description": "List of social media profiles"
          },
          "total_followers": {
            "type": "integer",
            "description": "Sum of followers across all platforms"
          },
          "total_following": {
            "type": "integer",
            "description": "Sum of following across all platforms"
          },
          "total_posts": {
            "type": "integer",
            "description": "Sum of posts across all platforms"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of when the data was last updated"
          }
        }
      },
      "ArtistProfileResponse": {
        "type": "object",
        "required": ["status", "profile"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "profile": {
            "$ref": "#/components/schemas/ArtistProfile",
            "description": "The artist's comprehensive profile information"
          }
        }
      },
      "ArtistProfileErrorResponse": {
        "type": "object",
        "required": ["status", "message"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "message": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "ChatRoom": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the chat room"
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "UUID of the associated account (can be null if not set)"
          },
          "topic": {
            "type": "string",
            "nullable": true,
            "description": "Optional topic or description of the room (null if not provided)"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of the last update to the room"
          },
          "artist_id": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "UUID of the associated artist account (null when not applicable)"
          }
        }
      },
      "GetChatsResponse": {
        "type": "object",
        "required": ["status", "chats"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "chats": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChatRoom"
            },
            "description": "Array of chat room objects"
          }
        }
      },
      "GetChatsErrorResponse": {
        "type": "object",
        "required": ["status", "error"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "CreateChatRequest": {
        "type": "object",
        "properties": {
          "artistId": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the artist account the chat is associated with"
          },
          "chatId": {
            "type": "string",
            "format": "uuid",
            "description": "UUID for the new chat (client-generated). If not provided, one will be generated automatically."
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the account to create the chat for. Only applicable for organization API keys - org keys can specify an accountId for any account within their organization. The Recoup admin organization can specify any accountId. If not provided, the chat is created for the API key's own account."
          },
          "topic": {
            "type": "string",
            "description": "Topic name for the new chat room (e.g., 'Pulse Feb 2'). To edit the topic of an existing room, use [PATCH /api/chats](/api-reference/chat/update)."
          }
        }
      },
      "CreateChatResponse": {
        "type": "object",
        "required": ["status", "chat"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "chat": {
            "$ref": "#/components/schemas/ChatRoom",
            "description": "The created chat room object"
          }
        }
      },
      "CreateChatErrorResponse": {
        "type": "object",
        "required": ["status", "message"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "message": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "UpdateChatRequest": {
        "type": "object",
        "required": ["chatId", "topic"],
        "properties": {
          "chatId": {
            "type": "string",
            "format": "uuid",
            "description": "The unique identifier (UUID) of the chat room to update"
          },
          "topic": {
            "type": "string",
            "minLength": 3,
            "maxLength": 50,
            "description": "The new display name for the chat room. Must be between 3 and 50 characters."
          }
        }
      },
      "UpdateChatResponse": {
        "type": "object",
        "required": ["status", "chat"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "chat": {
            "$ref": "#/components/schemas/ChatRoom",
            "description": "The updated chat room object"
          }
        }
      },
      "UpdateChatErrorResponse": {
        "type": "object",
        "required": ["status", "message"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "message": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "UIMessage": {
        "type": "object",
        "description": "A message in the chat conversation. See https://ai-sdk.dev/docs/reference/ai-sdk-core/ui-message for details.",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the message"
          },
          "role": {
            "type": "string",
            "enum": ["user", "assistant", "system"],
            "description": "The role of the message sender"
          },
          "content": {
            "type": "string",
            "description": "The text content of the message"
          }
        }
      },
      "ChatGenerateRequest": {
        "type": "object",
        "description": "Request body for chat generation. Exactly one of 'prompt' or 'messages' must be provided.",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Single text prompt for the assistant. Required if 'messages' is not provided."
          },
          "messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UIMessage"
            },
            "description": "Array of UIMessage objects for context. Required if 'prompt' is not provided."
          },
          "artistId": {
            "type": "string",
            "format": "uuid",
            "description": "The unique identifier of the artist (optional)"
          },
          "model": {
            "type": "string",
            "description": "The AI model to use for text generation (optional)",
            "example": "openai/gpt-5-mini"
          },
          "excludeTools": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Array of tool names to exclude from execution",
            "example": ["create_scheduled_actions"]
          },
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the chat room. If not provided, one will be generated automatically."
          },
          "topic": {
            "type": "string",
            "description": "Topic name for the new chat room (e.g., 'Pulse Feb 2'). Only applies when creating a new room - ignored if room already exists. To edit the topic of an existing room, use [PATCH /api/chats](/api-reference/chat/update)."
          }
        }
      },
      "ContentPart": {
        "type": "object",
        "description": "A part of the response content. See https://ai-sdk.dev/docs/reference/ai-sdk-core/generate-text#content for details.",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["text", "tool-call", "tool-result"],
            "description": "The type of content part"
          },
          "text": {
            "type": "string",
            "description": "The text content (present when type is 'text')"
          }
        }
      },
      "ChatGenerateUsage": {
        "type": "object",
        "description": "Token usage information with detailed breakdown",
        "properties": {
          "inputTokens": {
            "type": "integer",
            "description": "Number of input tokens processed"
          },
          "outputTokens": {
            "type": "integer",
            "description": "Number of output tokens generated"
          },
          "totalTokens": {
            "type": "integer",
            "description": "Total tokens used (input + output)"
          },
          "reasoningTokens": {
            "type": "integer",
            "description": "Number of reasoning tokens used"
          },
          "cachedInputTokens": {
            "type": "integer",
            "description": "Number of cached input tokens"
          }
        }
      },
      "ChatGenerateResponseMeta": {
        "type": "object",
        "description": "Additional response metadata",
        "properties": {
          "messages": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "Response messages"
          },
          "headers": {
            "type": "object",
            "description": "Response headers"
          },
          "body": {
            "type": "object",
            "description": "Response body"
          }
        }
      },
      "ChatGenerateResponse": {
        "type": "object",
        "description": "Response from the chat generation endpoint",
        "properties": {
          "text": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentPart"
            },
            "description": "Array of content parts from the AI model response"
          },
          "reasoningText": {
            "type": "string",
            "nullable": true,
            "description": "Optional reasoning or explanation for the response"
          },
          "sources": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "Optional array of sources used for the response"
          },
          "finishReason": {
            "type": "string",
            "description": "The reason why the generation finished",
            "example": "stop"
          },
          "usage": {
            "$ref": "#/components/schemas/ChatGenerateUsage",
            "description": "Token usage information"
          },
          "response": {
            "$ref": "#/components/schemas/ChatGenerateResponseMeta",
            "description": "Additional response metadata"
          }
        }
      },
      "ChatGenerateErrorResponse": {
        "type": "object",
        "required": ["status", "message"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "message": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "ChatStreamRequest": {
        "type": "object",
        "description": "Request body for chat streaming. Exactly one of 'prompt' or 'messages' must be provided.",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Single text prompt for the assistant. Required if 'messages' is not provided."
          },
          "messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UIMessage"
            },
            "description": "Array of UIMessage objects for context. Required if 'prompt' is not provided."
          },
          "artistId": {
            "type": "string",
            "format": "uuid",
            "description": "The unique identifier of the artist (optional)"
          },
          "model": {
            "type": "string",
            "description": "The AI model to use for text generation (optional)",
            "example": "openai/gpt-5-mini"
          },
          "excludeTools": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Array of tool names to exclude from execution",
            "example": ["create_scheduled_actions"]
          },
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the chat room. If not provided, one will be generated automatically."
          },
          "topic": {
            "type": "string",
            "description": "Topic name for the new chat room (e.g., 'Pulse Feb 2'). Only applies when creating a new room - ignored if room already exists. To edit the topic of an existing room, use [PATCH /api/chats](/api-reference/chat/update)."
          }
        }
      },
      "ChatStreamErrorResponse": {
        "type": "object",
        "required": ["status", "message"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "message": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "Organization": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the membership record"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the organization account"
          },
          "organization_name": {
            "type": "string",
            "description": "Display name of the organization"
          },
          "organization_image": {
            "type": "string",
            "nullable": true,
            "description": "Organization logo/image URL"
          }
        }
      },
      "GetOrganizationsResponse": {
        "type": "object",
        "required": ["status", "organizations"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "organizations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Organization"
            },
            "description": "List of organizations the account belongs to"
          }
        }
      },
      "OrganizationsErrorResponse": {
        "type": "object",
        "required": ["status", "message"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "message": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "CreateOrganizationRequest": {
        "type": "object",
        "required": ["name", "accountId"],
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the organization to create",
            "example": "My New Label"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "The account ID of the creator",
            "example": "123e4567-e89b-12d3-a456-426614174000"
          }
        }
      },
      "CreatedOrganization": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the new organization account"
          },
          "name": {
            "type": "string",
            "description": "Name of the organization"
          }
        }
      },
      "CreateOrganizationResponse": {
        "type": "object",
        "required": ["status", "organization"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "organization": {
            "$ref": "#/components/schemas/CreatedOrganization",
            "description": "The created organization"
          }
        }
      },
      "CreateWorkspaceRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the workspace (defaults to \"Untitled\")"
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the account to create the workspace for. Only applicable for organization API keys - org keys can specify an account_id for any account within their organization. If not provided, the workspace is created for the API key's own account."
          },
          "organization_id": {
            "type": "string",
            "format": "uuid",
            "description": "Organization to link the workspace to"
          }
        }
      },
      "CreateWorkspaceResponse": {
        "type": "object",
        "required": ["workspace"],
        "properties": {
          "workspace": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid"
              },
              "name": {
                "type": "string"
              },
              "account_id": {
                "type": "string",
                "format": "uuid"
              },
              "isWorkspace": {
                "type": "boolean"
              }
            }
          }
        }
      },
      "AddArtistToOrganizationRequest": {
        "type": "object",
        "required": ["artistId", "organizationId"],
        "properties": {
          "artistId": {
            "type": "string",
            "format": "uuid",
            "description": "The account ID of the artist to add",
            "example": "artist-account-uuid"
          },
          "organizationId": {
            "type": "string",
            "format": "uuid",
            "description": "The account ID of the organization",
            "example": "org-account-uuid"
          }
        }
      },
      "AddArtistToOrganizationResponse": {
        "type": "object",
        "required": ["status", "id"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the created artist-organization link"
          }
        }
      },
      "SpotifyImage": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "The source URL of the image"
          },
          "height": {
            "type": "integer",
            "nullable": true,
            "description": "The image height in pixels"
          },
          "width": {
            "type": "integer",
            "nullable": true,
            "description": "The image width in pixels"
          }
        }
      },
      "SpotifyExternalUrls": {
        "type": "object",
        "properties": {
          "spotify": {
            "type": "string",
            "description": "The Spotify URL for the object"
          }
        }
      },
      "SpotifyFollowers": {
        "type": "object",
        "properties": {
          "href": {
            "type": "string",
            "nullable": true,
            "description": "This will always be set to null"
          },
          "total": {
            "type": "integer",
            "description": "The total number of followers"
          }
        }
      },
      "SpotifyArtistObject": {
        "type": "object",
        "properties": {
          "external_urls": {
            "$ref": "#/components/schemas/SpotifyExternalUrls"
          },
          "followers": {
            "$ref": "#/components/schemas/SpotifyFollowers"
          },
          "genres": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of the genres the artist is associated with"
          },
          "href": {
            "type": "string",
            "description": "A link to the Web API endpoint providing full details"
          },
          "id": {
            "type": "string",
            "description": "The Spotify ID for the artist"
          },
          "images": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpotifyImage"
            },
            "description": "Images of the artist in various sizes"
          },
          "name": {
            "type": "string",
            "description": "The name of the artist"
          },
          "popularity": {
            "type": "integer",
            "description": "The popularity of the artist (0-100)"
          },
          "type": {
            "type": "string",
            "enum": ["artist"],
            "description": "The object type, always 'artist'"
          },
          "uri": {
            "type": "string",
            "description": "The Spotify URI for the artist"
          }
        }
      },
      "SpotifySimplifiedArtist": {
        "type": "object",
        "properties": {
          "external_urls": {
            "$ref": "#/components/schemas/SpotifyExternalUrls"
          },
          "href": {
            "type": "string",
            "description": "A link to the Web API endpoint providing full details"
          },
          "id": {
            "type": "string",
            "description": "The Spotify ID for the artist"
          },
          "name": {
            "type": "string",
            "description": "The name of the artist"
          },
          "type": {
            "type": "string",
            "enum": ["artist"],
            "description": "The object type, always 'artist'"
          },
          "uri": {
            "type": "string",
            "description": "The Spotify URI for the artist"
          }
        }
      },
      "SpotifyArtistsPaginated": {
        "type": "object",
        "properties": {
          "href": {
            "type": "string",
            "description": "A link to the Web API endpoint returning the full result"
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpotifyArtistObject"
            },
            "description": "List of artist objects"
          },
          "limit": {
            "type": "integer",
            "description": "The maximum number of items in the response"
          },
          "next": {
            "type": "string",
            "nullable": true,
            "description": "URL to the next page of items"
          },
          "offset": {
            "type": "integer",
            "description": "The offset of the items returned"
          },
          "previous": {
            "type": "string",
            "nullable": true,
            "description": "URL to the previous page of items"
          },
          "total": {
            "type": "integer",
            "description": "The total number of items available"
          }
        }
      },
      "SpotifySearchResponse": {
        "type": "object",
        "properties": {
          "artists": {
            "$ref": "#/components/schemas/SpotifyArtistsPaginated",
            "description": "Search results for artists (if type includes artist)"
          },
          "albums": {
            "type": "object",
            "description": "Search results for albums (if type includes album)"
          },
          "tracks": {
            "type": "object",
            "description": "Search results for tracks (if type includes track)"
          },
          "playlists": {
            "type": "object",
            "description": "Search results for playlists (if type includes playlist)"
          }
        }
      },
      "SpotifyGetArtistResponse": {
        "type": "object",
        "properties": {
          "artist": {
            "$ref": "#/components/schemas/SpotifyArtistObject",
            "nullable": true,
            "description": "The Spotify artist object (null if error)"
          },
          "error": {
            "type": "object",
            "nullable": true,
            "description": "Error object if request failed (null if successful)"
          }
        }
      },
      "SpotifySimplifiedAlbum": {
        "type": "object",
        "properties": {
          "album_type": {
            "type": "string",
            "enum": ["album", "single", "compilation"],
            "description": "The type of the album"
          },
          "total_tracks": {
            "type": "integer",
            "description": "The number of tracks in the album"
          },
          "available_markets": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Markets in which the album is available"
          },
          "external_urls": {
            "$ref": "#/components/schemas/SpotifyExternalUrls"
          },
          "href": {
            "type": "string",
            "description": "A link to the Web API endpoint providing full details"
          },
          "id": {
            "type": "string",
            "description": "The Spotify ID for the album"
          },
          "images": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpotifyImage"
            },
            "description": "The cover art for the album in various sizes"
          },
          "name": {
            "type": "string",
            "description": "The name of the album"
          },
          "release_date": {
            "type": "string",
            "description": "The date the album was first released"
          },
          "release_date_precision": {
            "type": "string",
            "enum": ["year", "month", "day"],
            "description": "The precision with which release_date value is known"
          },
          "restrictions": {
            "type": "object",
            "properties": {
              "reason": {
                "type": "string",
                "description": "The reason for the restriction"
              }
            },
            "description": "Included when a content restriction is applied"
          },
          "type": {
            "type": "string",
            "enum": ["album"],
            "description": "The object type, always 'album'"
          },
          "uri": {
            "type": "string",
            "description": "The Spotify URI for the album"
          },
          "artists": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpotifySimplifiedArtist"
            },
            "description": "The artists of the album"
          },
          "album_group": {
            "type": "string",
            "enum": ["album", "single", "compilation", "appears_on"],
            "description": "The field to distinguish albums by various groups"
          }
        }
      },
      "SpotifyArtistAlbumsResponse": {
        "type": "object",
        "properties": {
          "href": {
            "type": "string",
            "description": "A link to the Web API endpoint returning the full result"
          },
          "limit": {
            "type": "integer",
            "description": "The maximum number of items in the response"
          },
          "next": {
            "type": "string",
            "nullable": true,
            "description": "URL to the next page of items"
          },
          "offset": {
            "type": "integer",
            "description": "The offset of the items returned"
          },
          "previous": {
            "type": "string",
            "nullable": true,
            "description": "URL to the previous page of items"
          },
          "total": {
            "type": "integer",
            "description": "The total number of items available"
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpotifySimplifiedAlbum"
            },
            "description": "Array of simplified album objects"
          }
        }
      },
      "SpotifyTrack": {
        "type": "object",
        "properties": {
          "album": {
            "$ref": "#/components/schemas/SpotifySimplifiedAlbum",
            "description": "The album the track appears on"
          },
          "artists": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpotifySimplifiedArtist"
            },
            "description": "Artists who performed the track"
          },
          "available_markets": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Markets in which the track is available"
          },
          "disc_number": {
            "type": "integer",
            "description": "Disc number the track is on"
          },
          "duration_ms": {
            "type": "integer",
            "description": "Track length in milliseconds"
          },
          "explicit": {
            "type": "boolean",
            "description": "Whether the track has explicit lyrics"
          },
          "external_ids": {
            "type": "object",
            "properties": {
              "isrc": {
                "type": "string",
                "description": "International Standard Recording Code"
              },
              "ean": {
                "type": "string",
                "description": "International Article Number"
              },
              "upc": {
                "type": "string",
                "description": "Universal Product Code"
              }
            },
            "description": "Known external IDs for the track"
          },
          "external_urls": {
            "$ref": "#/components/schemas/SpotifyExternalUrls"
          },
          "href": {
            "type": "string",
            "description": "Link to the Web API endpoint with full details"
          },
          "id": {
            "type": "string",
            "description": "Spotify ID for the track"
          },
          "is_playable": {
            "type": "boolean",
            "description": "If true, the track is playable in the given market"
          },
          "linked_from": {
            "type": "object",
            "description": "Information about the originally requested track when track relinking is applied"
          },
          "restrictions": {
            "type": "object",
            "properties": {
              "reason": {
                "type": "string",
                "description": "The reason for the restriction"
              }
            },
            "description": "Content restriction information"
          },
          "name": {
            "type": "string",
            "description": "Track name"
          },
          "popularity": {
            "type": "integer",
            "description": "Popularity score (0-100)"
          },
          "preview_url": {
            "type": "string",
            "nullable": true,
            "description": "URL to a 30 second preview, if available"
          },
          "track_number": {
            "type": "integer",
            "description": "Track number on the album"
          },
          "type": {
            "type": "string",
            "enum": ["track"],
            "description": "The object type, always 'track'"
          },
          "uri": {
            "type": "string",
            "description": "The Spotify URI for the track"
          },
          "is_local": {
            "type": "boolean",
            "description": "Whether the track is from a local file"
          }
        }
      },
      "SpotifyArtistTopTracksResponse": {
        "type": "object",
        "properties": {
          "tracks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpotifyTrack"
            },
            "description": "Array of track objects"
          }
        }
      },
      "SpotifySimplifiedTrack": {
        "type": "object",
        "properties": {
          "artists": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpotifySimplifiedArtist"
            },
            "description": "The artists who performed the track"
          },
          "available_markets": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Markets in which the track is available"
          },
          "disc_number": {
            "type": "integer",
            "description": "Disc number the track is on"
          },
          "duration_ms": {
            "type": "integer",
            "description": "Track length in milliseconds"
          },
          "explicit": {
            "type": "boolean",
            "description": "Whether the track has explicit lyrics"
          },
          "external_urls": {
            "$ref": "#/components/schemas/SpotifyExternalUrls"
          },
          "href": {
            "type": "string",
            "description": "Link to the Web API endpoint"
          },
          "id": {
            "type": "string",
            "description": "Spotify ID for the track"
          },
          "is_playable": {
            "type": "boolean",
            "description": "If true, the track is playable"
          },
          "linked_from": {
            "type": "object",
            "description": "Track relinking info"
          },
          "restrictions": {
            "type": "object",
            "properties": {
              "reason": {
                "type": "string"
              }
            }
          },
          "name": {
            "type": "string",
            "description": "Track name"
          },
          "preview_url": {
            "type": "string",
            "nullable": true,
            "description": "URL to a 30 second preview"
          },
          "track_number": {
            "type": "integer",
            "description": "Track number on the album"
          },
          "type": {
            "type": "string",
            "enum": ["track"]
          },
          "uri": {
            "type": "string",
            "description": "Spotify URI for the track"
          },
          "is_local": {
            "type": "boolean",
            "description": "Whether from a local file"
          }
        }
      },
      "SpotifyAlbumTracks": {
        "type": "object",
        "properties": {
          "href": {
            "type": "string",
            "description": "A link to the Web API endpoint"
          },
          "limit": {
            "type": "integer",
            "description": "The maximum number of items in the response"
          },
          "next": {
            "type": "string",
            "nullable": true,
            "description": "URL to the next page of items"
          },
          "offset": {
            "type": "integer",
            "description": "The offset of the items returned"
          },
          "previous": {
            "type": "string",
            "nullable": true,
            "description": "URL to the previous page"
          },
          "total": {
            "type": "integer",
            "description": "Total number of items available"
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpotifySimplifiedTrack"
            },
            "description": "Array of simplified track objects"
          }
        }
      },
      "SpotifyCopyright": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "The copyright text"
          },
          "type": {
            "type": "string",
            "description": "The type of copyright"
          }
        }
      },
      "SpotifyAlbum": {
        "type": "object",
        "properties": {
          "album_type": {
            "type": "string",
            "enum": ["album", "single", "compilation"],
            "description": "The type of the album"
          },
          "total_tracks": {
            "type": "integer",
            "description": "The number of tracks in the album"
          },
          "available_markets": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Markets in which the album is available"
          },
          "external_urls": {
            "$ref": "#/components/schemas/SpotifyExternalUrls"
          },
          "href": {
            "type": "string",
            "description": "A link to the Web API endpoint providing full details"
          },
          "id": {
            "type": "string",
            "description": "The Spotify ID for the album"
          },
          "images": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpotifyImage"
            },
            "description": "The cover art for the album in various sizes"
          },
          "name": {
            "type": "string",
            "description": "The name of the album"
          },
          "release_date": {
            "type": "string",
            "description": "The date the album was first released"
          },
          "release_date_precision": {
            "type": "string",
            "enum": ["year", "month", "day"],
            "description": "The precision with which release_date value is known"
          },
          "restrictions": {
            "type": "object",
            "properties": {
              "reason": {
                "type": "string"
              }
            },
            "description": "Included when a content restriction is applied"
          },
          "type": {
            "type": "string",
            "enum": ["album"],
            "description": "The object type, always 'album'"
          },
          "uri": {
            "type": "string",
            "description": "The Spotify URI for the album"
          },
          "artists": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpotifySimplifiedArtist"
            },
            "description": "The artists of the album"
          },
          "tracks": {
            "$ref": "#/components/schemas/SpotifyAlbumTracks",
            "description": "The tracks of the album"
          },
          "copyrights": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpotifyCopyright"
            },
            "description": "Copyright statements of the album"
          },
          "external_ids": {
            "type": "object",
            "properties": {
              "isrc": {
                "type": "string"
              },
              "ean": {
                "type": "string"
              },
              "upc": {
                "type": "string"
              }
            },
            "description": "Known external IDs for the album"
          },
          "genres": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Deprecated. Always empty."
          },
          "label": {
            "type": "string",
            "description": "The label associated with the album"
          },
          "popularity": {
            "type": "integer",
            "description": "Popularity of the album (0-100)"
          }
        }
      },
      "SpotifyErrorResponse": {
        "type": "object",
        "properties": {
          "error": {
            "type": "object",
            "properties": {
              "status": {
                "type": "integer",
                "description": "HTTP status code"
              },
              "message": {
                "type": "string",
                "description": "Error message"
              }
            },
            "description": "Error details"
          }
        }
      },
      "TwitterPhoto": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Photo ID"
          },
          "url": {
            "type": "string",
            "description": "URL of the photo"
          }
        }
      },
      "TwitterVideo": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Video ID"
          },
          "preview": {
            "type": "string",
            "description": "URL of the video preview image"
          },
          "url": {
            "type": "string",
            "description": "URL of the video"
          }
        }
      },
      "Tweet": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Tweet ID"
          },
          "text": {
            "type": "string",
            "description": "Tweet text content"
          },
          "username": {
            "type": "string",
            "description": "Username of the tweet author"
          },
          "timestamp": {
            "type": "integer",
            "description": "Unix timestamp (ms) of when the tweet was posted"
          },
          "createdAt": {
            "type": "string",
            "description": "ISO timestamp of when the tweet was posted"
          },
          "isReply": {
            "type": "boolean",
            "description": "Whether the tweet is a reply"
          },
          "isRetweet": {
            "type": "boolean",
            "description": "Whether the tweet is a retweet"
          },
          "likes": {
            "type": "integer",
            "description": "Number of likes"
          },
          "retweetCount": {
            "type": "integer",
            "description": "Number of retweets"
          },
          "replies": {
            "type": "integer",
            "description": "Number of replies"
          },
          "photos": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TwitterPhoto"
            },
            "description": "Array of photo objects"
          },
          "videos": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TwitterVideo"
            },
            "description": "Array of video objects"
          },
          "urls": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Array of URLs included in the tweet"
          },
          "permanentUrl": {
            "type": "string",
            "description": "Permanent URL to the tweet"
          },
          "quotedStatusId": {
            "type": "string",
            "description": "ID of the quoted tweet (if applicable)"
          },
          "inReplyToStatusId": {
            "type": "string",
            "description": "ID of the tweet this is replying to (if applicable)"
          },
          "hashtags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Array of hashtags in the tweet"
          }
        }
      },
      "TwitterSearchResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "description": "Status of the request",
            "enum": ["success", "error"]
          },
          "tweets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Tweet"
            },
            "description": "List of tweet objects"
          }
        }
      },
      "TwitterTrendsResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "description": "Status of the request",
            "enum": ["success", "error"]
          },
          "trends": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of current trending topics on Twitter"
          }
        }
      },
      "TwitterErrorResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "message": {
            "type": "string",
            "description": "Error message"
          }
        }
      },
      "SocialScrapeRequest": {
        "type": "object",
        "required": ["social_id"],
        "properties": {
          "social_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the social profile to scrape. Obtain this from the Get Artist Socials API."
          }
        }
      },
      "SocialPost": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the social's social_posts record"
          },
          "post_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the social's posts record"
          },
          "social_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the social's socials record"
          },
          "post_url": {
            "type": "string",
            "description": "Direct URL to the post on the platform"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of when the post data was last updated"
          }
        }
      },
      "SocialPostsPagination": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "integer",
            "description": "Total number of posts available"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "limit": {
            "type": "integer",
            "description": "Number of posts per page"
          },
          "total_pages": {
            "type": "integer",
            "description": "Total number of pages available"
          }
        }
      },
      "SocialPostsResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success", "error"],
            "description": "Status of the request"
          },
          "posts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SocialPost"
            },
            "description": "List of social media posts"
          },
          "pagination": {
            "$ref": "#/components/schemas/SocialPostsPagination"
          }
        }
      },
      "SocialErrorResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "message": {
            "type": "string",
            "description": "Error message"
          }
        }
      },
      "GeneratedImage": {
        "type": "object",
        "description": "A generated image file from the AI model",
        "properties": {
          "base64": {
            "type": "string",
            "description": "Image file as a base64 encoded string"
          },
          "uint8Array": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "Image file as a Uint8Array (represented as array of numbers in JSON)"
          },
          "mediaType": {
            "type": "string",
            "description": "The IANA media type of the file (e.g., 'image/png', 'image/jpeg')"
          }
        }
      },
      "ImageResponseMeta": {
        "type": "object",
        "description": "Response metadata from the AI provider",
        "properties": {
          "finishReason": {
            "type": "string",
            "description": "Reason the generation finished (e.g., 'stop')"
          }
        }
      },
      "ImageProviderMetadata": {
        "type": "object",
        "description": "Metadata from the AI provider about the generation",
        "properties": {
          "model": {
            "type": "string",
            "description": "The AI model used for generation (e.g., 'dall-e-3', 'gpt-image-1')"
          },
          "size": {
            "type": "string",
            "description": "The size of the generated image (e.g., '1024x1024')"
          }
        }
      },
      "ImageUsage": {
        "type": "object",
        "description": "Token usage information for the image generation",
        "properties": {
          "promptTokens": {
            "type": "integer",
            "description": "Number of tokens used in the prompt"
          },
          "completionTokens": {
            "type": "integer",
            "description": "Number of tokens used in the completion (typically 0 for image generation)"
          },
          "totalTokens": {
            "type": "integer",
            "description": "Total tokens used"
          }
        }
      },
      "ArweaveTransaction": {
        "type": "object",
        "description": "Arweave transaction object for the stored image",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the Arweave transaction"
          },
          "last_tx": {
            "type": "string",
            "description": "Last transaction reference"
          },
          "owner": {
            "type": "string",
            "description": "Owner address of the transaction"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "Tags associated with the transaction"
          },
          "target": {
            "type": "string",
            "description": "Target address (empty for data transactions)"
          },
          "quantity": {
            "type": "string",
            "description": "Amount transferred (typically '0' for data transactions)"
          },
          "data": {
            "type": "string",
            "description": "Transaction data (may be empty in response)"
          },
          "reward": {
            "type": "string",
            "description": "Mining reward for the transaction"
          },
          "signature": {
            "type": "string",
            "description": "Transaction signature"
          },
          "format": {
            "type": "integer",
            "description": "Transaction format version"
          }
        }
      },
      "InProcessMoment": {
        "type": "object",
        "description": "In Process moment metadata for provenance and ownership tracking",
        "properties": {
          "contractAddress": {
            "type": "string",
            "description": "Smart contract address for the moment"
          },
          "tokenId": {
            "type": "string",
            "description": "Token ID of the minted moment"
          },
          "hash": {
            "type": "string",
            "description": "Transaction hash of the moment mint"
          },
          "chainId": {
            "type": "integer",
            "description": "Chain ID (e.g., 8453 for Base)"
          }
        }
      },
      "ImageGenerationResponse": {
        "type": "object",
        "description": "Response from the image generation endpoint, extending Experimental_GenerateImageResult from the AI SDK",
        "properties": {
          "images": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GeneratedImage"
            },
            "description": "Array of generated image objects"
          },
          "warnings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Array of warning messages, if any"
          },
          "responses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ImageResponseMeta"
            },
            "description": "Array of response metadata from the AI provider"
          },
          "providerMetadata": {
            "$ref": "#/components/schemas/ImageProviderMetadata"
          },
          "usage": {
            "$ref": "#/components/schemas/ImageUsage"
          },
          "imageUrl": {
            "type": "string",
            "description": "Permanent Arweave URL where the image is stored"
          },
          "arweaveResult": {
            "$ref": "#/components/schemas/ArweaveTransaction"
          },
          "moment": {
            "$ref": "#/components/schemas/InProcessMoment"
          }
        }
      },
      "ImageGenerationErrorResponse": {
        "type": "object",
        "properties": {
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "TranscribeAudioRequest": {
        "type": "object",
        "required": ["audio_url", "account_id", "artist_account_id"],
        "properties": {
          "audio_url": {
            "type": "string",
            "description": "Public URL to the audio file (mp3, wav, m4a, webm)",
            "example": "https://example.com/song.mp3"
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "Owner account ID for file storage",
            "example": "550e8400-e29b-41d4-a716-446655440000"
          },
          "artist_account_id": {
            "type": "string",
            "format": "uuid",
            "description": "Artist account ID for file storage",
            "example": "550e8400-e29b-41d4-a716-446655440001"
          },
          "title": {
            "type": "string",
            "description": "Optional title for the audio and transcription files",
            "example": "My Song"
          },
          "include_timestamps": {
            "type": "boolean",
            "description": "Whether to include timestamps in the markdown transcript",
            "default": false
          }
        }
      },
      "TranscribeFileInfo": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the file record in the database"
          },
          "fileName": {
            "type": "string",
            "description": "Name of the saved file"
          },
          "storageKey": {
            "type": "string",
            "description": "Storage path in Supabase Storage"
          }
        }
      },
      "TranscribeAudioResponse": {
        "type": "object",
        "required": ["success", "audioFile", "transcriptFile", "text"],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether the transcription was successful"
          },
          "audioFile": {
            "$ref": "#/components/schemas/TranscribeFileInfo",
            "description": "Information about the saved audio file"
          },
          "transcriptFile": {
            "$ref": "#/components/schemas/TranscribeFileInfo",
            "description": "Information about the saved transcript file"
          },
          "text": {
            "type": "string",
            "description": "The full transcription text"
          },
          "language": {
            "type": "string",
            "description": "Detected language code (e.g., 'en', 'es', 'fr')"
          }
        }
      },
      "TranscribeAudioErrorResponse": {
        "type": "object",
        "required": ["error"],
        "properties": {
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "SongArtist": {
        "type": "object",
        "description": "Artist associated with a song",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the artist account"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "Name of the artist (can be null)"
          },
          "timestamp": {
            "type": "integer",
            "nullable": true,
            "description": "Timestamp associated with the artist account (can be null)"
          }
        }
      },
      "Song": {
        "type": "object",
        "description": "A song with its metadata and associated artists",
        "properties": {
          "isrc": {
            "type": "string",
            "description": "International Standard Recording Code (primary key)"
          },
          "name": {
            "type": "string",
            "description": "Name of the song"
          },
          "album": {
            "type": "string",
            "description": "Name of the album the song belongs to"
          },
          "notes": {
            "type": "string",
            "description": "Notes for the song"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of when the song data was last updated"
          },
          "artists": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SongArtist"
            },
            "description": "Array of artist objects associated with this song"
          }
        }
      },
      "SongsResponse": {
        "type": "object",
        "description": "Response containing songs data",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success", "error"],
            "description": "Status of the request"
          },
          "songs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Song"
            },
            "description": "Array of song objects with artist information"
          },
          "error": {
            "type": "string",
            "description": "Error message (only present if status is 'error')"
          }
        }
      },
      "SongsErrorResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "CreateSongInput": {
        "type": "object",
        "required": ["isrc"],
        "properties": {
          "isrc": {
            "type": "string",
            "description": "International Standard Recording Code of the song to create or fetch"
          },
          "name": {
            "type": "string",
            "description": "Optional. Song name, applied only if internal search cannot find valid info"
          },
          "album": {
            "type": "string",
            "description": "Optional. Album name, applied only if internal search cannot find valid info"
          },
          "notes": {
            "type": "string",
            "description": "Optional. Notes for the song, applied only if internal search cannot find valid info"
          },
          "artists": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Optional array of artist names, applied only if internal search cannot find valid info"
          }
        }
      },
      "CreateSongsRequest": {
        "type": "object",
        "required": ["songs"],
        "properties": {
          "songs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateSongInput"
            },
            "description": "Array of song inputs for bulk create/fetch"
          }
        }
      },
      "Catalog": {
        "type": "object",
        "description": "A catalog with its metadata",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the catalog"
          },
          "name": {
            "type": "string",
            "description": "Name of the catalog"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of when the catalog was created"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of when the catalog was last updated"
          }
        }
      },
      "CatalogsResponse": {
        "type": "object",
        "description": "Response containing catalogs data",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success", "error"],
            "description": "Status of the request"
          },
          "catalogs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Catalog"
            },
            "description": "Array of catalog objects"
          },
          "error": {
            "type": "string",
            "description": "Error message (only present if status is 'error')"
          }
        }
      },
      "CatalogsErrorResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "CreateCatalogInput": {
        "type": "object",
        "required": ["account_id"],
        "properties": {
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "The account to associate the catalog with"
          },
          "name": {
            "type": "string",
            "description": "Catalog name to create if catalog_id is omitted"
          },
          "catalog_id": {
            "type": "string",
            "format": "uuid",
            "description": "Existing catalog ID to link to the account"
          }
        }
      },
      "CreateCatalogsRequest": {
        "type": "object",
        "required": ["catalogs"],
        "properties": {
          "catalogs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateCatalogInput"
            },
            "description": "Array of catalog inputs for bulk create/link operations"
          }
        }
      },
      "DeleteCatalogInput": {
        "type": "object",
        "required": ["catalog_id", "account_id"],
        "properties": {
          "catalog_id": {
            "type": "string",
            "format": "uuid",
            "description": "Catalog ID to remove"
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID whose relationship will be removed"
          }
        }
      },
      "DeleteCatalogsRequest": {
        "type": "object",
        "required": ["catalogs"],
        "properties": {
          "catalogs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeleteCatalogInput"
            },
            "description": "Array of catalog-account pairs to remove"
          }
        }
      },
      "CatalogSong": {
        "type": "object",
        "description": "A song within a catalog with its metadata and associated artists",
        "properties": {
          "catalog_id": {
            "type": "string",
            "format": "uuid",
            "description": "Catalog ID this song entry is associated with"
          },
          "isrc": {
            "type": "string",
            "description": "International Standard Recording Code (primary key)"
          },
          "name": {
            "type": "string",
            "description": "Name of the song"
          },
          "album": {
            "type": "string",
            "description": "Name of the album the song belongs to"
          },
          "lyrics": {
            "type": "string",
            "description": "Full lyrics of the song"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of when the song data was last updated"
          },
          "artists": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SongArtist"
            },
            "description": "Array of artist objects associated with this song"
          }
        }
      },
      "CatalogSongsPagination": {
        "type": "object",
        "description": "Pagination metadata for catalog songs response",
        "properties": {
          "total_count": {
            "type": "integer",
            "description": "Total number of songs in the catalog"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "limit": {
            "type": "integer",
            "description": "Number of songs per page"
          },
          "total_pages": {
            "type": "integer",
            "description": "Total number of pages available"
          }
        }
      },
      "CatalogSongsResponse": {
        "type": "object",
        "description": "Response containing catalog songs data with pagination",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success", "error"],
            "description": "Status of the request"
          },
          "songs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CatalogSong"
            },
            "description": "Array of song objects with artist information"
          },
          "pagination": {
            "$ref": "#/components/schemas/CatalogSongsPagination",
            "description": "Pagination metadata for the response"
          },
          "error": {
            "type": "string",
            "description": "Error message (only present if status is 'error')"
          }
        }
      },
      "CatalogSongsErrorResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "AddCatalogSongInput": {
        "type": "object",
        "required": ["catalog_id", "isrc"],
        "properties": {
          "catalog_id": {
            "type": "string",
            "format": "uuid",
            "description": "Catalog ID to which the song will be added"
          },
          "isrc": {
            "type": "string",
            "description": "Song ISRC to associate to the catalog"
          },
          "name": {
            "type": "string",
            "description": "Optional. Applied only if internal search cannot find valid info for ISRC"
          },
          "album": {
            "type": "string",
            "description": "Optional. Applied only if internal search cannot find valid info for ISRC"
          },
          "notes": {
            "type": "string",
            "description": "Optional. Applied only if internal search cannot find valid info for ISRC"
          },
          "artists": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Optional array of artist names. Applied only if internal search lacks info"
          }
        }
      },
      "AddCatalogSongsRequest": {
        "type": "object",
        "required": ["songs"],
        "properties": {
          "songs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AddCatalogSongInput"
            },
            "description": "Array of songs for batch updates"
          }
        }
      },
      "DeleteCatalogSongInput": {
        "type": "object",
        "required": ["catalog_id", "isrc"],
        "properties": {
          "catalog_id": {
            "type": "string",
            "format": "uuid",
            "description": "Catalog ID from which the song will be removed"
          },
          "isrc": {
            "type": "string",
            "description": "Song ISRC to remove from the catalog"
          }
        }
      },
      "DeleteCatalogSongsRequest": {
        "type": "object",
        "required": ["songs"],
        "properties": {
          "songs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeleteCatalogSongInput"
            },
            "description": "Array of songs for batch deletes"
          }
        }
      },
      "ArtistFan": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the fan's social profile"
          },
          "username": {
            "type": "string",
            "description": "Username or handle on the platform"
          },
          "avatar": {
            "type": "string",
            "description": "URL to the fan's avatar/profile image"
          },
          "profile_url": {
            "type": "string",
            "description": "Full URL to the fan's profile on the platform"
          },
          "region": {
            "type": "string",
            "description": "Geographic region or location of the fan"
          },
          "bio": {
            "type": "string",
            "description": "Fan's biography or profile description"
          },
          "followerCount": {
            "type": "integer",
            "description": "Number of followers the fan has"
          },
          "followingCount": {
            "type": "integer",
            "description": "Number of accounts the fan is following"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of when the fan data was last updated"
          }
        }
      },
      "ArtistFansPagination": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "integer",
            "description": "Total number of records available"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "limit": {
            "type": "integer",
            "description": "Number of records per page"
          },
          "total_pages": {
            "type": "integer",
            "description": "Total number of pages available"
          }
        }
      },
      "ArtistFansResponse": {
        "type": "object",
        "required": ["status", "fans", "pagination"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "fans": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ArtistFan"
            },
            "description": "List of social profiles from fans across all platforms"
          },
          "pagination": {
            "$ref": "#/components/schemas/ArtistFansPagination",
            "description": "Pagination metadata for the response"
          }
        }
      },
      "ArtistFansErrorResponse": {
        "type": "object",
        "required": ["status", "error"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "SegmentFan": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the fan_segments record"
          },
          "username": {
            "type": "string",
            "description": "Username or handle on the platform"
          },
          "avatar": {
            "type": "string",
            "description": "URL to the fan's avatar/profile image"
          },
          "profile_url": {
            "type": "string",
            "description": "Full URL to the fan's profile on the platform"
          },
          "segment_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the fan's segments record"
          },
          "segment_name": {
            "type": "string",
            "description": "Name of the segment (e.g., 'Twitter Followers')"
          },
          "fan_social_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the fan's socials media profile account"
          },
          "region": {
            "type": "string",
            "description": "Geographic region or location of the fan"
          },
          "bio": {
            "type": "string",
            "description": "Fan's biography or profile description"
          },
          "follower_count": {
            "type": "integer",
            "description": "Number of followers the fan has"
          },
          "following_count": {
            "type": "integer",
            "description": "Number of accounts the fan is following"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of when the fan data was last updated"
          }
        }
      },
      "ArtistPost": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the post"
          },
          "post_url": {
            "type": "string",
            "description": "Direct URL to the post on the social platform"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of when the post was last updated"
          }
        }
      },
      "ArtistPostsPagination": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "integer",
            "description": "Total number of posts available"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "limit": {
            "type": "integer",
            "description": "Number of posts per page"
          },
          "total_pages": {
            "type": "integer",
            "description": "Total number of pages available"
          }
        }
      },
      "ArtistPostsResponse": {
        "type": "object",
        "required": ["status", "posts", "pagination"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "posts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ArtistPost"
            },
            "description": "List of posts from the artist across all social platforms"
          },
          "pagination": {
            "$ref": "#/components/schemas/ArtistPostsPagination",
            "description": "Pagination metadata for the response"
          }
        }
      },
      "ArtistPostsErrorResponse": {
        "type": "object",
        "required": ["status", "error"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "PostComment": {
        "type": "object",
        "required": ["id", "post_id", "social_id", "comment", "commented_at", "username", "profile_url", "post_url"],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the comment record"
          },
          "post_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the post this comment belongs to"
          },
          "social_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the social profile that made the comment"
          },
          "comment": {
            "type": "string",
            "description": "Text content of the comment"
          },
          "commented_at": {
            "type": "string",
            "format": "date-time",
            "description": "ISO timestamp of when the comment was posted"
          },
          "username": {
            "type": "string",
            "description": "Username of the commenter"
          },
          "avatar": {
            "type": "string",
            "nullable": true,
            "description": "URL to the commenter's avatar image"
          },
          "profile_url": {
            "type": "string",
            "description": "URL to the commenter's profile"
          },
          "post_url": {
            "type": "string",
            "description": "URL to the post where the comment was made"
          },
          "region": {
            "type": "string",
            "nullable": true,
            "description": "Geographic region of the commenter"
          },
          "bio": {
            "type": "string",
            "nullable": true,
            "description": "Commenter's biography or description"
          },
          "follower_count": {
            "type": "integer",
            "nullable": true,
            "description": "Number of followers the commenter has"
          },
          "following_count": {
            "type": "integer",
            "nullable": true,
            "description": "Number of accounts the commenter follows"
          }
        }
      },
      "PostCommentsPagination": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "integer",
            "description": "Total number of comments available"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "limit": {
            "type": "integer",
            "description": "Number of comments per page"
          },
          "total_pages": {
            "type": "integer",
            "description": "Total number of pages available"
          }
        }
      },
      "PostCommentsResponse": {
        "type": "object",
        "required": ["status", "comments", "pagination"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "comments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PostComment"
            },
            "description": "List of comments for the specified post"
          },
          "pagination": {
            "$ref": "#/components/schemas/PostCommentsPagination",
            "description": "Pagination metadata for the response"
          }
        }
      },
      "PostCommentsErrorResponse": {
        "type": "object",
        "required": ["status", "error"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "Comment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the comment"
          },
          "post_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the associated post"
          },
          "social_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the social profile who made the comment"
          },
          "comment": {
            "type": "string",
            "description": "Comment text content"
          },
          "commented_at": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp with timezone of when the comment was made"
          }
        }
      },
      "CommentsPagination": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "integer",
            "description": "Total number of comments available"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "limit": {
            "type": "integer",
            "description": "Number of comments per page"
          },
          "total_pages": {
            "type": "integer",
            "description": "Total number of pages available"
          }
        }
      },
      "CommentsResponse": {
        "type": "object",
        "required": ["status", "comments", "pagination"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "comments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Comment"
            },
            "description": "List of comments for the specified artist or post"
          },
          "pagination": {
            "$ref": "#/components/schemas/CommentsPagination",
            "description": "Pagination metadata for the response"
          }
        }
      },
      "CommentsErrorResponse": {
        "type": "object",
        "required": ["status", "error"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "SegmentFansPagination": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "integer",
            "description": "Total number of records available"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "limit": {
            "type": "integer",
            "description": "Number of records per page"
          },
          "total_pages": {
            "type": "integer",
            "description": "Total number of pages available"
          }
        }
      },
      "SegmentFansResponse": {
        "type": "object",
        "required": ["status", "fans", "pagination"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "fans": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentFan"
            },
            "description": "List of social profiles from fans in the segment"
          },
          "pagination": {
            "$ref": "#/components/schemas/SegmentFansPagination",
            "description": "Pagination metadata for the response"
          }
        }
      },
      "SegmentFansErrorResponse": {
        "type": "object",
        "required": ["status", "error"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "StripeSubscription": {
        "type": "object",
        "description": "A Stripe subscription object. For detailed information about all available properties, see the Stripe Subscription API documentation: https://docs.stripe.com/api/subscriptions/retrieve",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the subscription"
          },
          "object": {
            "type": "string",
            "enum": ["subscription"],
            "description": "String representing the object's type"
          },
          "customer": {
            "type": "string",
            "description": "ID of the customer who owns this subscription"
          },
          "status": {
            "type": "string",
            "enum": ["active", "canceled", "incomplete", "incomplete_expired", "past_due", "trialing", "unpaid"],
            "description": "The status of the subscription"
          },
          "currency": {
            "type": "string",
            "description": "Three-letter ISO currency code"
          },
          "current_period_start": {
            "type": "integer",
            "description": "Start of the current period (Unix timestamp)"
          },
          "current_period_end": {
            "type": "integer",
            "description": "End of the current period (Unix timestamp)"
          },
          "cancel_at_period_end": {
            "type": "boolean",
            "description": "If true, the subscription will be canceled at the end of the current period"
          },
          "created": {
            "type": "integer",
            "description": "Time at which the subscription was created (Unix timestamp)"
          },
          "items": {
            "type": "object",
            "description": "List of subscription items, each with an attached price",
            "properties": {
              "object": {
                "type": "string",
                "enum": ["list"]
              },
              "data": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string"
                    },
                    "object": {
                      "type": "string",
                      "enum": ["subscription_item"]
                    },
                    "price": {
                      "type": "object",
                      "properties": {
                        "id": {
                          "type": "string"
                        },
                        "currency": {
                          "type": "string"
                        },
                        "unit_amount": {
                          "type": "integer",
                          "description": "Price amount in cents"
                        },
                        "recurring": {
                          "type": "object",
                          "properties": {
                            "interval": {
                              "type": "string",
                              "enum": ["day", "week", "month", "year"]
                            },
                            "interval_count": {
                              "type": "integer"
                            }
                          }
                        }
                      }
                    },
                    "quantity": {
                      "type": "integer"
                    }
                  }
                }
              },
              "has_more": {
                "type": "boolean"
              },
              "total_count": {
                "type": "integer"
              }
            }
          },
          "latest_invoice": {
            "type": "string",
            "description": "ID of the most recent invoice for this subscription"
          },
          "livemode": {
            "type": "boolean",
            "description": "Indicates if in live mode (true) or test mode (false)"
          },
          "metadata": {
            "type": "object",
            "description": "Set of key-value pairs attached to the subscription"
          }
        }
      },
      "SubscriptionResponse": {
        "type": "object",
        "required": ["status", "subscription"],
        "description": "Response for standard accounts with Stripe subscriptions",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "subscription": {
            "$ref": "#/components/schemas/StripeSubscription",
            "description": "The full Stripe subscription object"
          }
        }
      },
      "EnterpriseSubscriptionResponse": {
        "type": "object",
        "required": ["status", "isEnterprise"],
        "description": "Response for accounts with enterprise plans",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the request"
          },
          "isEnterprise": {
            "type": "boolean",
            "enum": [true],
            "description": "Indicates that the account has an enterprise plan"
          }
        }
      },
      "SubscriptionErrorResponse": {
        "type": "object",
        "required": ["status", "error"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Status of the request"
          },
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      },
      "CreateSandboxRequest": {
        "type": "object",
        "description": "Request body for creating a new sandbox. All fields are optional - if no command or prompt is provided, sandbox is created without triggering a command execution task. Use prompt as a shortcut to run OpenCode with a given prompt instead of specifying command/args manually.",
        "properties": {
          "command": {
            "type": "string",
            "minLength": 1,
            "description": "The command to execute in the sandbox environment. If omitted, the sandbox is created without running any command.",
            "example": "ls"
          },
          "args": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Optional arguments to pass to the command.",
            "example": ["-la", "/home"]
          },
          "cwd": {
            "type": "string",
            "description": "Optional working directory for command execution.",
            "example": "/home/user"
          },
          "prompt": {
            "type": "string",
            "minLength": 1,
            "description": "A prompt to pass to OpenCode in the sandbox. When provided, the sandbox will execute `opencode run \"<prompt>\"`. Cannot be used together with command.",
            "example": "create a hello world index.html"
          }
        }
      },
      "Sandbox": {
        "type": "object",
        "required": ["sandboxId", "sandboxStatus", "timeout", "createdAt"],
        "description": "A sandbox environment instance",
        "properties": {
          "sandboxId": {
            "type": "string",
            "description": "Unique identifier for the sandbox",
            "example": "sbx_abc123def456"
          },
          "sandboxStatus": {
            "type": "string",
            "enum": ["pending", "running", "stopping", "stopped", "failed"],
            "description": "Current lifecycle state of the sandbox",
            "example": "running"
          },
          "timeout": {
            "type": "integer",
            "description": "Milliseconds remaining before the sandbox stops automatically",
            "example": 300000
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "ISO 8601 timestamp when the sandbox was created",
            "example": "2024-01-15T10:30:00.000Z"
          },
          "runId": {
            "type": "string",
            "description": "Unique identifier for the command execution run. Only present if a command was provided when creating the sandbox. Use this with [GET /api/tasks/runs](/api-reference/tasks/runs) to check the status and retrieve results.",
            "example": "run_xyz789abc123"
          }
        }
      },
      "SandboxesResponse": {
        "type": "object",
        "required": ["status", "sandboxes"],
        "description": "Response containing sandbox information",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success", "error"],
            "description": "Status of the request"
          },
          "sandboxes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Sandbox"
            },
            "description": "Array of sandbox objects"
          },
          "snapshot_id": {
            "type": "string",
            "description": "The account's saved snapshot ID used for creating new sandboxes. Null if no snapshot has been saved.",
            "example": "snap_abc123def456",
            "nullable": true
          },
          "github_repo": {
            "type": "string",
            "description": "The GitHub repository URL associated with the account's sandbox environment. Used as the filesystem source when restoring sandboxes.",
            "example": "https://github.com/username/repo",
            "nullable": true
          },
          "filetree": {
            "type": "array",
            "nullable": true,
            "description": "The recursive file tree of the account's GitHub repository. Null if no github_repo is set or if the fetch fails.",
            "items": {
              "$ref": "#/components/schemas/FileTreeEntry"
            }
          },
          "error": {
            "type": "string",
            "description": "Error message (only present if status is error)"
          }
        }
      },
      "SandboxErrorResponse": {
        "type": "object",
        "required": ["error"],
        "properties": {
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong",
            "example": "Failed to create sandbox"
          }
        }
      },
      "SetupSandboxRequest": {
        "type": "object",
        "properties": {
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the account to set up the sandbox for. Only applicable for organization API keys - org keys can specify an account_id for any account within their organization. If not provided, sets up the sandbox for the API key's own account."
          }
        }
      },
      "SetupSandboxResponse": {
        "type": "object",
        "required": ["status", "runId"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Status of the setup operation"
          },
          "runId": {
            "type": "string",
            "description": "The Trigger.dev run ID for the setup-sandbox background task. Use this with [GET /api/tasks/runs](/api-reference/tasks/runs) to check the status and retrieve results.",
            "example": "run_abc123def456"
          }
        }
      },
      "DeleteSandboxRequest": {
        "type": "object",
        "properties": {
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the account to delete the sandbox for. Only applicable for organization API keys - org keys can specify an account_id for any account within their organization. If not provided, deletes the sandbox for the API key's own account."
          }
        }
      },
      "DeleteSandboxResponse": {
        "type": "object",
        "required": ["status"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success", "error"],
            "description": "Status of the delete operation"
          },
          "deleted_snapshot": {
            "nullable": true,
            "description": "The snapshot record that was deleted. Null if no snapshot existed for the account.",
            "$ref": "#/components/schemas/UpdateSnapshotResponse"
          },
          "error": {
            "type": "string",
            "description": "Error message (only present if status is error)"
          }
        }
      },
      "UpdateSnapshotRequest": {
        "type": "object",
        "required": [],
        "properties": {
          "snapshotId": {
            "type": "string",
            "description": "The snapshot ID to set for the account. This snapshot will be used as the base environment when creating new sandboxes.",
            "example": "snap_abc123def456"
          },
          "github_repo": {
            "type": "string",
            "format": "uri",
            "description": "The GitHub repository URL to associate with the account's sandbox environment. Must be a valid URL.",
            "example": "https://github.com/org/repo"
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the account to update the snapshot for. Only applicable for organization API keys - org keys can specify an account_id for any account within their organization. If not provided, updates the snapshot for the API key's own account."
          }
        }
      },
      "UpdateSnapshotResponse": {
        "type": "object",
        "required": ["account_id", "snapshot_id", "expires_at", "github_repo", "created_at"],
        "properties": {
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "The account ID this snapshot belongs to",
            "example": "550e8400-e29b-41d4-a716-446655440000"
          },
          "snapshot_id": {
            "type": "string",
            "description": "The snapshot ID that was set for the account",
            "example": "snap_abc123def456"
          },
          "expires_at": {
            "type": "string",
            "format": "date-time",
            "description": "When the snapshot expires",
            "example": "2027-01-01T00:00:00.000Z"
          },
          "github_repo": {
            "type": "string",
            "nullable": true,
            "description": "The GitHub repository URL associated with the sandbox",
            "example": "https://github.com/org/repo"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the snapshot record was created",
            "example": "2025-01-01T00:00:00.000Z"
          }
        }
      },
      "Pulse": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the pulse"
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the associated account"
          },
          "active": {
            "type": "boolean",
            "description": "Whether the pulse is active (defaults to true)"
          }
        }
      },
      "PulseResponse": {
        "type": "object",
        "required": ["status", "pulse"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success", "error"],
            "description": "Status of the request"
          },
          "pulse": {
            "$ref": "#/components/schemas/Pulse",
            "description": "The pulse object"
          },
          "error": {
            "type": "string",
            "description": "Error message (only present if status is error)"
          }
        }
      },
      "PulsesResponse": {
        "type": "object",
        "required": ["status", "pulses"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success", "error"],
            "description": "Status of the request"
          },
          "pulses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Pulse"
            },
            "description": "Array of pulse objects. For personal keys, contains one pulse. For org keys, contains pulses for all accounts in the organization."
          },
          "error": {
            "type": "string",
            "description": "Error message (only present if status is error)"
          }
        }
      },
      "UpdatePulseRequest": {
        "type": "object",
        "required": ["active"],
        "properties": {
          "active": {
            "type": "boolean",
            "description": "Whether to enable or disable the pulse",
            "example": true
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the account to update the pulse for. Only applicable for organization API keys - org keys can specify an account_id for any account within their organization. If not provided, updates the pulse for the API key's own account."
          }
        }
      },
      "TaskRunResponse": {
        "type": "object",
        "required": ["status", "taskIdentifier", "createdAt"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["pending", "complete", "failed"],
            "description": "The current status of the task run"
          },
          "data": {
            "description": "The response data from the completed task. Only present when status is `complete`. Structure varies based on the task type.",
            "nullable": true
          },
          "error": {
            "type": "string",
            "description": "Error message describing why the task run failed. Only present when status is `failed`."
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "description": "Structured metadata emitted by the task during execution. Contains `currentStep` (string) and `logs` (string array) for real-time progress tracking.",
            "properties": {
              "currentStep": {
                "type": "string",
                "description": "The current step the task is executing"
              },
              "logs": {
                "type": "array",
                "items": { "type": "string" },
                "description": "Array of log messages emitted during task execution"
              }
            }
          },
          "taskIdentifier": {
            "type": "string",
            "description": "The task type identifier (e.g. 'setup-sandbox', 'run-sandbox-command')"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the task run was created"
          },
          "startedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the task run started executing"
          },
          "finishedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the task run finished (null if still running)"
          },
          "durationMs": {
            "type": "number",
            "nullable": true,
            "description": "Total duration in milliseconds (null if still running)"
          }
        }
      },
      "FileTreeEntry": {
        "type": "object",
        "required": ["path", "type", "sha"],
        "description": "A single entry in a GitHub repository file tree",
        "properties": {
          "path": {
            "type": "string",
            "description": "The file or directory path relative to the repository root",
            "example": "src/index.ts"
          },
          "type": {
            "type": "string",
            "enum": ["blob", "tree"],
            "description": "The type of entry: blob for files, tree for directories"
          },
          "sha": {
            "type": "string",
            "description": "The SHA hash of the entry",
            "example": "abc123def456"
          },
          "size": {
            "type": "integer",
            "description": "The size of the file in bytes. Only present for blob entries.",
            "example": 1024
          }
        }
      },
      "RenderVideoRequest": {
        "type": "object",
        "required": ["compositionId"],
        "properties": {
          "compositionId": {
            "type": "string",
            "description": "The composition ID to render (e.g., \"SocialPost\", \"UpdatesAnnouncement\", \"CommitShowcase\")",
            "example": "SocialPost"
          },
          "inputProps": {
            "type": "object",
            "additionalProperties": true,
            "description": "Input props to pass to the composition. Structure depends on the composition being rendered.",
            "default": {},
            "example": {
              "videoUrl": "https://fal.media/example.mp4",
              "captionText": "my brain has 100 tabs open",
              "hasAudio": false
            }
          },
          "width": {
            "type": "integer",
            "minimum": 1,
            "maximum": 3840,
            "default": 720,
            "description": "Output video width in pixels",
            "example": 720
          },
          "height": {
            "type": "integer",
            "minimum": 1,
            "maximum": 3840,
            "default": 1280,
            "description": "Output video height in pixels",
            "example": 1280
          },
          "fps": {
            "type": "integer",
            "minimum": 1,
            "maximum": 60,
            "default": 30,
            "description": "Frames per second for the output video",
            "example": 30
          },
          "durationInFrames": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1800,
            "default": 240,
            "description": "Total number of frames to render. At 30 fps, 240 frames = 8 seconds.",
            "example": 240
          },
          "codec": {
            "type": "string",
            "enum": ["h264", "h265", "vp8", "vp9"],
            "default": "h264",
            "description": "Video codec for the output file",
            "example": "h264"
          }
        }
      },
      "RenderVideoResponse": {
        "type": "object",
        "required": ["status", "runId"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["processing"],
            "description": "Indicates the render task has been triggered and is processing"
          },
          "runId": {
            "type": "string",
            "description": "The Trigger.dev run ID for the render task. Use this with [GET /api/tasks/runs](/api-reference/tasks/runs) to check the status and retrieve the rendered video URL when complete.",
            "example": "run_abc123def456"
          }
        }
      },
      "RenderVideoErrorResponse": {
        "type": "object",
        "required": ["status", "error"],
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Indicates the request failed"
          },
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong",
            "example": "compositionId is required"
          },
          "missing_fields": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of missing or invalid fields, if applicable"
          }
        }
      },
      "ContentCreateRequest": {
        "type": "object",
        "description": "Parameters for triggering the content creation pipeline. Provide either `artist_account_id` or `artist_slug` to identify the artist  at least one is required. If both are provided, `artist_account_id` takes precedence.",
        "properties": {
          "artist_account_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the artist account to create content for. Use [GET /api/artists](/api-reference/artists/list) to find artist account IDs.",
            "example": "1873859c-dd37-4e9a-9bac-80d3558527a9"
          },
          "artist_slug": {
            "type": "string",
            "description": "The artist directory name (slug) as an alternative to `artist_account_id`. Must match a directory under `artists/` in the account's GitHub repository. Convenient when calling from a sandbox where the directory name is already known.",
            "example": "gatsby-grace"
          },
          "template": {
            "type": "string",
            "description": "The template to use for content generation. Defines the visual style, scene, and prompt configuration. If omitted, defaults to `artist-caption-bedroom`. See [GET /api/content/templates](/api-reference/content/templates) for available options.",
            "example": "artist-caption-stage",
            "default": "artist-caption-bedroom"
          },
          "lipsync": {
            "type": "boolean",
            "description": "Whether to generate video with lip-synced audio. When `true`, uses an audio-to-video model that bakes audio into the video for lip movement. When `false`, generates video from the image alone and overlays audio in post. If omitted, the template's default workflow is used.",
            "example": false
          },
          "account_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the account that owns the artist. Only applicable for organization API keys  org keys can specify an account_id for any account within their organization. If not provided, uses the API key's own account.",
            "example": "550e8400-e29b-41d4-a716-446655440000"
          }
        }
      },
      "ContentCreateResponse": {
        "type": "object",
        "required": ["runId", "status", "artist", "template"],
        "description": "Confirmation that the content creation pipeline has been triggered.",
        "properties": {
          "runId": {
            "type": "string",
            "description": "The run ID for the background pipeline task. Use this with [GET /api/tasks/runs](/api-reference/tasks/runs) to poll for progress and retrieve the output video path when complete.",
            "example": "run_abc123def456"
          },
          "status": {
            "type": "string",
            "enum": ["triggered"],
            "description": "Indicates the pipeline has been triggered and is starting"
          },
          "artist": {
            "type": "string",
            "description": "The artist slug the pipeline is running for",
            "example": "gatsby-grace"
          },
          "template": {
            "type": "string",
            "description": "The template being used for this run",
            "example": "artist-caption-stage"
          },
          "lipsync": {
            "type": "boolean",
            "description": "Whether lip-sync mode is enabled for this run",
            "example": false
          }
        }
      },
      "ContentCreateErrorResponse": {
        "type": "object",
        "required": ["error"],
        "description": "Returned when the artist is missing required files or the template is not found. Includes actionable instructions for resolving each issue.",
        "properties": {
          "error": {
            "type": "string",
            "description": "Human-readable error summary",
            "example": "Artist 'new-artist' is not ready for content creation"
          },
          "ready": {
            "type": "boolean",
            "description": "Always `false` when this error is returned",
            "example": false
          },
          "missing": {
            "type": "array",
            "description": "List of missing files with severity and fix instructions. Only present when the artist fails validation.",
            "items": {
              "$ref": "#/components/schemas/ContentMissingFile"
            }
          },
          "available_templates": {
            "type": "array",
            "description": "List of valid template names. Only present when the requested template was not found.",
            "items": {
              "type": "string"
            },
            "example": ["artist-caption-bedroom", "artist-caption-outside", "artist-caption-stage"]
          }
        }
      },
      "ContentErrorResponse": {
        "type": "object",
        "required": ["error"],
        "properties": {
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong",
            "example": "Unauthorized"
          }
        }
      },
      "ContentTemplatesResponse": {
        "type": "object",
        "required": ["templates"],
        "description": "List of available content creation templates.",
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentTemplate"
            }
          }
        }
      },
      "ContentTemplate": {
        "type": "object",
        "required": ["name", "description", "defaultLipsync"],
        "description": "A content creation template that defines the visual style and composition for generated videos.",
        "properties": {
          "name": {
            "type": "string",
            "description": "Template identifier. Pass this as the `template` field in [POST /api/content/create](/api-reference/content/create).",
            "example": "artist-caption-bedroom"
          },
          "description": {
            "type": "string",
            "description": "Human-readable description of the template's visual style",
            "example": "Moody purple bedroom setting with caption overlay"
          },
          "defaultLipsync": {
            "type": "boolean",
            "description": "Whether this template defaults to lip-sync mode when the `lipsync` flag is not explicitly set",
            "example": false
          }
        }
      },
      "ContentValidateResponse": {
        "type": "object",
        "required": ["ready", "artist"],
        "description": "Validation report for an artist's content creation readiness.",
        "properties": {
          "ready": {
            "type": "boolean",
            "description": "`true` if the artist has all required files and the pipeline can run. `false` if required files are missing.",
            "example": true
          },
          "artist": {
            "type": "string",
            "description": "The artist slug that was validated",
            "example": "gatsby-grace"
          },
          "songs": {
            "type": "integer",
            "description": "Number of songs found in the artist's `songs/` directory",
            "example": 17
          },
          "templates": {
            "type": "array",
            "description": "Available templates that can be used with this artist",
            "items": {
              "type": "string"
            },
            "example": ["artist-caption-bedroom", "artist-caption-outside", "artist-caption-stage"]
          },
          "checks": {
            "type": "object",
            "description": "Per-file validation results. Only present when `ready` is `true`.",
            "properties": {
              "face_guide": {
                "$ref": "#/components/schemas/ContentValidationCheck"
              },
              "artist_context": {
                "$ref": "#/components/schemas/ContentValidationCheck"
              },
              "audience_context": {
                "$ref": "#/components/schemas/ContentValidationCheck"
              },
              "era_config": {
                "$ref": "#/components/schemas/ContentValidationCheck"
              },
              "pipeline_config": {
                "$ref": "#/components/schemas/ContentValidationCheck"
              },
              "songs": {
                "allOf": [
                  { "$ref": "#/components/schemas/ContentValidationCheck" },
                  {
                    "type": "object",
                    "properties": {
                      "count": {
                        "type": "integer",
                        "description": "Number of songs found",
                        "example": 17
                      }
                    }
                  }
                ]
              }
            }
          },
          "missing": {
            "type": "array",
            "description": "List of missing files with severity and fix instructions. Only present when `ready` is `false`.",
            "items": {
              "$ref": "#/components/schemas/ContentMissingFile"
            }
          }
        }
      },
      "ContentValidationCheck": {
        "type": "object",
        "required": ["status"],
        "description": "Status of a single validation check.",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["ok", "missing", "warning"],
            "description": "Whether the file was found",
            "example": "ok"
          }
        }
      },
      "ContentMissingFile": {
        "type": "object",
        "required": ["file", "severity", "description", "fix"],
        "description": "A missing file that prevents or degrades content creation.",
        "properties": {
          "file": {
            "type": "string",
            "description": "Relative path of the missing file within the artist directory",
            "example": "context/images/face-guide.png"
          },
          "severity": {
            "type": "string",
            "enum": ["required", "recommended"],
            "description": "`required` means the pipeline will fail without this file. `recommended` means the pipeline will run but output quality is degraded.",
            "example": "required"
          },
          "description": {
            "type": "string",
            "description": "What this file is used for in the pipeline",
            "example": "Face guide image used for AI image generation"
          },
          "fix": {
            "type": "string",
            "description": "Actionable instructions for creating or adding the missing file",
            "example": "Generate a face guide using fal-ai/nano-banana-pro/edit with 2-3 reference photos of the artist"
          }
        }
      },
      "ContentEstimateResponse": {
        "type": "object",
        "required": ["workflows"],
        "description": "Cost estimates based on live fal.ai pricing. When `compare` is `false`, the `workflows` array contains a single entry. When `true`, it contains all available profiles.",
        "properties": {
          "workflows": {
            "type": "array",
            "description": "One or more workflow cost breakdowns",
            "items": {
              "$ref": "#/components/schemas/ContentWorkflowEstimate"
            }
          },
          "comparison": {
            "description": "Side-by-side summary. Only present when `compare` is `true` and multiple workflows are returned.",
            "$ref": "#/components/schemas/ContentEstimateComparison"
          },
          "batch": {
            "type": "object",
            "description": "Batch cost projection. Only present when `batch` > 1.",
            "properties": {
              "count": {
                "type": "integer",
                "description": "Number of videos in the batch",
                "example": 30
              },
              "cheapestTotal": {
                "type": "number",
                "format": "float",
                "description": "Total cost for the batch using the cheapest workflow",
                "example": 5.40
              },
              "mostExpensiveTotal": {
                "type": "number",
                "format": "float",
                "description": "Total cost for the batch using the most expensive workflow",
                "example": 28.50
              }
            }
          }
        }
      },
      "ContentWorkflowEstimate": {
        "type": "object",
        "required": ["name", "perVideo", "steps"],
        "description": "Cost breakdown for a single workflow profile.",
        "properties": {
          "name": {
            "type": "string",
            "description": "Workflow profile name",
            "example": "Current (image-to-video)"
          },
          "perVideo": {
            "type": "number",
            "format": "float",
            "description": "Total estimated cost per video in USD",
            "example": 0.82
          },
          "steps": {
            "type": "array",
            "description": "Per-step cost breakdown showing where the money goes",
            "items": {
              "$ref": "#/components/schemas/ContentStepEstimate"
            }
          },
          "costBreakdown": {
            "type": "object",
            "description": "Summary of the biggest cost driver",
            "properties": {
              "mostExpensiveStep": {
                "type": "string",
                "description": "Name of the step that costs the most",
                "example": "Generate Video"
              },
              "mostExpensivePercent": {
                "type": "integer",
                "description": "Percentage of total cost from the most expensive step",
                "example": 68
              }
            }
          }
        }
      },
      "ContentStepEstimate": {
        "type": "object",
        "required": ["name", "model", "cost", "note"],
        "description": "Cost details for a single pipeline step.",
        "properties": {
          "name": {
            "type": "string",
            "description": "Pipeline step name",
            "example": "Generate Image"
          },
          "model": {
            "type": "string",
            "description": "The AI model or service used for this step",
            "example": "fal-ai/nano-banana-pro/edit"
          },
          "cost": {
            "type": "number",
            "format": "float",
            "description": "Estimated cost for this step in USD",
            "example": 0.04
          },
          "unit": {
            "type": "string",
            "description": "Billing unit type (e.g., `images`, `seconds`, `megapixels`). Not present for free steps.",
            "example": "images"
          },
          "unitPrice": {
            "type": "number",
            "format": "float",
            "description": "Price per billing unit in USD. Not present for free steps.",
            "example": 0.04
          },
          "note": {
            "type": "string",
            "description": "Human-readable calculation detail",
            "example": "1 call"
          }
        }
      },
      "ContentEstimateComparison": {
        "type": "object",
        "required": ["cheapest", "cheapestPerVideo", "mostExpensive", "mostExpensivePerVideo", "savingsPercent"],
        "description": "Summary comparing the cheapest and most expensive workflow options.",
        "properties": {
          "cheapest": {
            "type": "string",
            "description": "Name of the cheapest workflow profile",
            "example": "Budget (no upscale, LTX video)"
          },
          "cheapestPerVideo": {
            "type": "number",
            "format": "float",
            "description": "Cost per video for the cheapest workflow",
            "example": 0.18
          },
          "mostExpensive": {
            "type": "string",
            "description": "Name of the most expensive workflow profile",
            "example": "Current (audio-to-video)"
          },
          "mostExpensivePerVideo": {
            "type": "number",
            "format": "float",
            "description": "Cost per video for the most expensive workflow",
            "example": 0.95
          },
          "savingsPercent": {
            "type": "integer",
            "description": "Percentage savings between the cheapest and most expensive workflows",
            "example": 81
          }
        }
      },
      "SongAnalyzeRequest": {
        "type": "object",
        "properties": {
          "preset": {
            "type": "string",
            "enum": ["catalog_metadata", "mood_tags", "lyric_transcription", "mix_feedback", "song_description", "music_theory", "similar_artists", "sample_detection", "sync_brief_match", "audience_profile", "content_advisory", "playlist_pitch", "artist_development_notes", "full_report"],
            "description": "Name of a curated analysis preset. Use instead of prompt for structured, optimized output. The 'full_report' preset runs all 13 presets in parallel and returns a comprehensive report.",
            "example": "catalog_metadata"
          },
          "prompt": {
            "type": "string",
            "minLength": 1,
            "maxLength": 24000,
            "description": "Text prompt or question about the music",
            "example": "Describe the genre, tempo, and mood of this track."
          },
          "audio_url": {
            "type": "string",
            "format": "uri",
            "description": "Public URL to an audio file (MP3, WAV, or FLAC  up to 20 minutes)",
            "example": "https://example.com/song.mp3"
          },
          "max_new_tokens": {
            "type": "integer",
            "minimum": 1,
            "maximum": 2048,
            "default": 512,
            "description": "Maximum number of tokens to generate",
            "example": 512
          },
          "temperature": {
            "type": "number",
            "minimum": 0,
            "maximum": 2,
            "default": 1.0,
            "description": "Controls output creativity  higher values produce more varied responses",
            "example": 0.7
          },
          "top_p": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "default": 1.0,
            "description": "Nucleus sampling probability cutoff",
            "example": 0.9
          },
          "do_sample": {
            "type": "boolean",
            "default": false,
            "description": "Enable sampling (set true when using temperature or top_p)",
            "example": false
          }
        }
      },
      "SongAnalyzeResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["success"],
            "description": "Request status"
          },
          "response": {
            "type": "string",
            "description": "The model's text response about the music"
          },
          "elapsed_seconds": {
            "type": "number",
            "format": "float",
            "description": "Inference time in seconds"
          }
        }
      },
      "SongAnalyzeErrorResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"],
            "description": "Error status"
          },
          "error": {
            "type": "string",
            "description": "Error message describing what went wrong"
          }
        }
      }
    },
    "securitySchemes": {
      "bearerAuth": {
        "type": "http",
        "scheme": "bearer"
      },
      "apiKeyAuth": {
        "type": "apiKey",
        "in": "header",
        "name": "x-api-key",
        "description": "Your Recoup API key. [Learn more](/quickstart#api-keys)."
      }
    }
  }
}
